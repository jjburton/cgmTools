/*
    TSM Tools
    1.6.2
    
    Copyright © 2010 Bohdon Sayre
    All Rights Reserved.
    bo@bohdon.com
    
    Description:
        Contains tools for modding/enhancing the TSM 2.0 rig.
    
    unique prefix: btsmt
    
    Version 1.6:
        > btsmtFreeArmsAndLegs -> free arms and legs for movement independent of the body
        > bstmtToeCtls -> sets up toe controls for any toes in the scene
        > minor fixes to the TSM2 controls menu procedures, IKFKSwitch fix thanks to Nick Matthews and Marcus Ng!
        > btsmtSpaceSwitching setups up space switching for all/multiple hands
        > changed hand ctl size to be dynamically based on joint distances
        > accounted for a weird situation where arms and legs are named as if they are the second instance (LeftLeg2_.., LeftArm2_...) but no first instances exist
        > btsmtHandCtls -> sets up hand circle hand controls on any hands in the scene
        > btsmtFootRoll -> sets up the foot roll attribute on the foot control (includes fixing the main controls pivot)
        > btsmtAutoBendSpine -> auto bending spine with the ability to switch between normal and auto
        > btsmtSpaceSwitching -> enables space switching on the hands and head IK
        > btsmtMirrorTSMInfluences -> mirrors selected influences when in the pre-rigging stage. doesn't affect center influences
    
    Feel free to email me with any bugs, comments, or requests!
*/

//====================================================================================================
//TSM TOOLS WINDOW
global proc boTSMTools() {
	//window name
	$win = "btsmtWin";
	
	//check for pre-existing window
	if (`window -ex $win`) deleteUI -wnd $win;
	
	//create window
	window -rtf 1 -mb 1 -mxb 0 -t "TSM Tools 1.6" -mnc ("window -e -t \"TSM Tools 1.6\" "+$win+";") $win;
	window -e -h 10 $win;
	
	
	//main layout
	columnLayout -adj 1 btsmtMainColumn;
			text -en 0 -l "Pre-Rigging Tools:";
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtMTIFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Mirror TSM Influences"
						-c "source boTSMTools; btsmtMirrorTSMInfluences;"
						btsmtWinMTIButton;
					text -l "Mirrors the selected TSM influences to the opposite\nside. Works on both vertex and transformation levels,\ndoes not affect body or center influences."
						btsmtWinMTIText;
					setParent btsmtMainColumn;
			separator -h 3 -st "in";
			separator -h 12 -st none;
			text -en 0 -l "Post-Rigging Tools:";
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtSSSFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Setup Space Switching"
						-c "source boTSMTools; btsmtSpaceSwitching;"
						btsmtWinSSSButton;
					text -l "Sets up space switching on the hands for world,\n shoulder, hips, and head space. Sets up space\nswitching on the head for world and shoulder space."
						btsmtWinSSSText;
					setParent btsmtMainColumn;
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtABSFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Setup Auto Bend Spine"
						-c "source boTSMTools; btsmtAutoBendSpine;"
						btsmtWinABSButton;
					text -l "Sets up the middle spine control to be able\nto switch between auto bend and normal modes."
						btsmtWinABSText;
					setParent btsmtMainColumn;
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtFRLFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Setup Foot Roll"
						-c "source boTSMTools; btsmtFootRoll;"
						btsmtWinFRLButton;
					text -l "Sets up foot rolling for your feet.\nFirst click will prompt you to position a locator.\nSecond click will do all the cool stuff."
						btsmtWinFRLText;
					setParent btsmtMainColumn;
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtHCTFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Setup Hand Controls"
						-c "source boTSMTools; btsmtHandCtls;"
						btsmtWinHCTButton;
					text -l "Sets up circle control curves for all fingers.\n Allows you to animate all three axes rather than\nlimiting finger rotation to one attribute."
						btsmtWinHCTText;
					setParent btsmtMainColumn;
			separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtTCTFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Setup Toe Controls"
						-c "source boTSMTools; btsmtToeCtls;"
						btsmtWinTCTButton;
					text -l "Sets up circle control curves for all toes.\n Allows you to animate all three axes rather than\nlimiting toe rotation to one attribute."
						btsmtWinTCTText;
					setParent btsmtMainColumn;
            separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtFALFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Free Arms and Legs"
						-c "source boTSMTools; btsmtFreeArmsAndLegs 1 1;"
						btsmtWinFALButton;
					text -l "Frees the arms and legs for movement independent of the body.\n Allows you to move where the arms and legs meet the torso."
						btsmtWinFALText;
					setParent btsmtMainColumn;
            separator -h 3 -st "in";
			frameLayout -bv 0 -mw 4 -mh 4 -lv 0 btsmtHIJFrame;
				columnLayout -adj 1 -rs 2;
					button -l "Hide All TSM Joints"
						-c "source boTSMTools; btsmtHideJoints;"
						btsmtWinHIJButton;
                    popupMenu -mm 1 -b 3;
                        menuItem -l "Show All TSM Joints" -c "btsmtShowJoints";
					text -l "Hides all TSM Joints without causing controls to disappear."
						btsmtWinHIJText;
					setParent btsmtMainColumn;
            

	window -e -w 325 $win;
	showWindow $win;
}


//====================================================================================================
//MIRROR TSM INFLUENCES
global proc btsmtMirrorTSMInfluences() {
	$selList = `ls -sl`;
	if (!size($selList))
		return;

	int $objsMirrored = 0;

	string $obj;
	for ($obj in $selList) {
		if (`gmatch $obj "*influence*"` == 1) {
			int $found = 0;
			string $mirrorObj;
			if (`gmatch $obj "Left*"` == 1) {
				//perform mirror to Right object
				$mirrorObj = `substitute "Left" $obj "Right"`;
				$found = 1;
			} else if (`gmatch $obj "Right*"` == 1) {
				//perform mirror to Left object
				$mirrorObj = `substitute "Right" $obj "Left"`;
				$found = 1;
			}
			if ($found) {
				//create blendshape, turn up, then delete blendshape
				string $newBlend[] = `blendShape $obj $mirrorObj`;
				setAttr ($newBlend[0]+".w[0]") 1;
				delete -ch $mirrorObj;
				vector $objTrans = `getAttr ($obj+".t")`;
				vector $objRot = `getAttr ($obj+".r")`;
				vector $objScale = `getAttr ($obj+".s")`;
				setAttr ($mirrorObj+".tx") ($objTrans.x);
				setAttr ($mirrorObj+".ty") ($objTrans.y);
				setAttr ($mirrorObj+".tz") (-1 * $objTrans.z);
				setAttr ($mirrorObj+".rx") (-1 * $objRot.x);
				setAttr ($mirrorObj+".ry") (-1 * $objRot.y);
				setAttr ($mirrorObj+".rz") ($objRot.z);
				setAttr ($mirrorObj+".sx") ($objScale.x);
				setAttr ($mirrorObj+".sy") ($objScale.y);
				setAttr ($mirrorObj+".sz") ($objScale.z);
				if (`gmatch $mirrorObj "*Leg*"` == 1) {
					setAttr ($mirrorObj+".sz") (-1 * $objScale.z);
				}
				$objsMirrored ++;
			}
        }
    }
    
	if (!$objsMirrored) {
		print ("// no influences were selected...\n");
	} else {
		print ("// "+$objsMirrored+" influences(s) successfully mirrored!\n");
	}
}



//====================================================================================================
//SETUP SPACE SWITCHING
global proc btsmtSpaceSwitching() {
	
	
	if (`objExists "LeftArm*_Arm_IK_Spaces"`) {
		warning ("space switching has already been setup!");
		return;
	}
	
	//space switching for arms
	//
	//just get all arms in the scene, and apply the methods to each of them
	string $armList[] = `ls "*Arm*_Arm_IK"`;
	for ($arm in $armList) {
		//group IK arms to create Space node
		select ($arm);
		group -n ($arm+"_Spaces");
	
		//constrain to IK (world)
		select IK ($arm+"_Spaces");
		parentConstraint -mo -weight 1;
	
		//constrain to Spine_joint7 (shoulders)
		select Spine_joint7 ($arm+"_Spaces");
		parentConstraint -mo -weight 1;
	
		//constrain to Spine_joint1 (hips)
		select Spine_joint1 ($arm+"_Spaces");
		parentConstraint -mo -weight 1;

		//constrain to Head_joint3 (head)
		select Head_joint3 ($arm+"_Spaces");
		parentConstraint -mo -weight 1;

		
		//create attributes on controls
		addAttr -ln "______"  -at "enum" -en "______:"  ($arm);
		setAttr -e -keyable 0 -cb 1 ($arm+".______");
		//
		addAttr -ln "worldSpace" -at double -min 0 -max 1 ($arm);
		addAttr -ln "shoulderSpace" -at double -min 0 -max 1 ($arm);
		addAttr -ln "hipSpace" -at double -min 0 -max 1 ($arm);
		addAttr -ln "headSpace" -at double -min 0 -max 1 ($arm);
		setAttr -e -keyable 1 ($arm+".worldSpace") 1;
		setAttr -e -keyable 1 ($arm+".shoulderSpace");
		setAttr -e -keyable 1 ($arm+".hipSpace");
		setAttr -e -keyable 1 ($arm+".headSpace");

		//connect attributes to weights
		connectAttr -f ($arm+".worldSpace") ($arm+"_Spaces_parentConstraint1.IKW0");
		connectAttr -f ($arm+".shoulderSpace") ($arm+"_Spaces_parentConstraint1.Spine_joint7W1");
		connectAttr -f ($arm+".hipSpace") ($arm+"_Spaces_parentConstraint1.Spine_joint1W2");
		connectAttr -f ($arm+".headSpace") ($arm+"_Spaces_parentConstraint1.Head_joint3W3");
	}
	
	
	//space switching for the head
	//
	//group to create Space node
	select Head_Head_IK;
	group -n "Head_Head_IK_Spaces";
	
	//constrain to IK (world)
	select IK Head_Head_IK_Spaces;
	parentConstraint -mo -weight 1;
	
	//contrain to Spine_joint7 (shoulders)
	select Spine_joint7 Head_Head_IK_Spaces;
	parentConstraint -mo -weight 1;
	
	//create attributes on control
	addAttr -ln "______" -at "enum" -en "______:" Head_Head_IK;
	setAttr -e -keyable 0 -cb 1 Head_Head_IK.______;
	//
	addAttr -ln "worldSpace" -at double -min 0 -max 1 Head_Head_IK;
	setAttr -e -keyable 1 Head_Head_IK.worldSpace 1;
	
	//create reverse node and connect attributes
	shadingNode -asUtility reverse -n Head_Head_IK_Spaces_reverse;
	connectAttr -f Head_Head_IK.worldSpace Head_Head_IK_Spaces_parentConstraint1.IKW0;
	connectAttr -f Head_Head_IK.worldSpace Head_Head_IK_Spaces_reverse.inputX;
	connectAttr -f Head_Head_IK_Spaces_reverse.outputX Head_Head_IK_Spaces_parentConstraint1.Spine_joint7W1;
	
	select -cl;
	print ("// yay! space switching is coool!\n");
}


//====================================================================================================
//AUTO BEND SPINE
	global proc btsmtAutoBendSpine() {
	if (size(`ls "Spine_middlenullIK"`) > 1) {
			error ("more than one Spine_middlenullIK was found in this scene, there can only be one rig in the scene");
	}
	if (`objExists "Spine_middle_autoBendNode"`) {
		warning ("auto bend back has already been setup!");
		return;
	}

	if (`objExists "Spine_middlenull_pointConstraint1"`)
		delete Spine_middlenull_pointConstraint1;
	if (`objExists "Spine_middlenull_aimConstraint1"`)
		delete Spine_middlenull_aimConstraint1;

	string $connectionsT[] = `listConnections -s 1 Spine_middlenullIK.tx`;
	string $connectionsR[] = `listConnections -s 1 Spine_middlenullIK.rx`;
	if (size($connectionsT) > 0 || size($connectionsR) > 0) {
		error ("please delete all constraints on Spine_middlenullIK first");
		return;
	}
	
	//group to create autoBendNode
	select Spine_middlenullIK;
	group -n "Spine_middle_autoBendNode";
	
	//create normal mode point contraints
	select Spine_Torso_IK Spine_middle_autoBendNode;
	pointConstraint -mo -weight 1;
	select Spine_Pelvis_IK Spine_middle_autoBendNode;
	pointConstraint -mo -weight 1;
	
	//create parent constraints
	select Spine_Torso_IK Spine_middlenullIK;
	parentConstraint -mo -weight 1;
	select Spine_Pelvis_IK Spine_middlenullIK;
	parentConstraint -mo -weight 1;
	select Spine_middle_autoBendNode Spine_middlenullIK;
	parentConstraint -mo -weight 1;
	
	//create attributes on control
	addAttr -ln "______" -at "enum" -en "______:" Spine_Middle_IK;
	setAttr -e -keyable 0 -cb 1 Spine_Middle_IK.______;
	//
	addAttr -ln "autoBend" -at double -min 0 -max 1 Spine_Middle_IK;
	setAttr -e -keyable 1 Spine_Middle_IK.autoBend 0.5;
	
	//create reverse node and connect attributes
	shadingNode -asUtility reverse -n Spine_Middle_IK_reverse;
	connectAttr -f Spine_Middle_IK.autoBend Spine_Middle_IK_reverse.inputX;
	connectAttr -f Spine_Middle_IK.autoBend Spine_middlenullIK_parentConstraint1.Spine_Torso_IKW0;
	connectAttr -f Spine_Middle_IK.autoBend Spine_middlenullIK_parentConstraint1.Spine_Pelvis_IKW1;
	connectAttr -f Spine_Middle_IK_reverse.outputX Spine_middlenullIK_parentConstraint1.Spine_middle_autoBendNodeW2;
	
	select -cl;
	print ("// yay! auto bending backs are coool!\n");
}


//====================================================================================================
//SETUP FOOT ROLL
global proc btsmtFootRoll() {
	select -cl;
	
	string $leftLegList[] = `ls "LeftLeg*_IK_Leg"`;
	int $useDigit = 0; //accounts for Beavan's strange incident of having LeftLeg2_... but no LeftLeg_...
	
	if (size($leftLegList) > 1) {
		error ("more than one LeftLeg(*)_IK_Leg was found in this scene, there can only be one rig/one set of legs in the scene");
	}
	
	if ($leftLegList[0] != "LeftLeg_IK_Leg") {
		$useDigit = (int)`match "[0-9]+" $leftLegList[0]`;
		if ($useDigit == 0)
			error ("can't setup foot roll, leg naming scheme does not follow common TSM methods");
	}
	
	if ($useDigit)
		print ("// Naming scheme was different than expected... using LeftLeg"+$useDigit+"_...\n");
	
	string $setupCheckNode = "LeftLeg_ballRollReverse";
	if ($useDigit)
		$setupCheckNode = ("LeftLeg"+$useDigit+"_ballRollReverse");
	
	if (size(`ls $setupCheckNode`) > 0) {
		warning ("foot rolling has already been setup!");
		return;
	}
	
	//check for the heel roll locators
	string $heelLoc = "btsmtFootRoll_heelLocator";
	if (!`objExists $heelLoc`) {
		btsmtFootRollLocators($useDigit);
		return;
	}
	vector $heelPt = `xform -q -ws -rp $heelLoc`;
	delete $heelLoc;
	
	string $sides[] = {"Left", "Right"};
	for ($side in $sides) {
		string $leg = $side+"Leg";
		if ($useDigit) //Beavan's issue...
			$leg = $leg+$useDigit;
			
		string $node; //buffer for holding node names
		vector $pt; //buffer for holding vectors
		string $heelRoll, $toePivot, $ballRoll, $ballRollReverse;
		
		//create the heelRoll, ballRoll, ballRollReverse nodes
			//heelRoll
		$node = ($leg+"_recompensate");
		$heelRoll = `group -n ($leg+"_heelRoll") $node`;
		if ($side == "Left") {
			xform -ws -piv ($heelPt.x) ($heelPt.y) ($heelPt.z) $heelRoll;
		} else if ($side == "Right") {
			xform -ws -piv (-$heelPt.x) ($heelPt.y) ($heelPt.z) $heelRoll;
		}
		
			//ballRoll and ballRollReverse
		$node = ($leg+"_Heel_Pivot");
		$pt = `xform -q -ws -rp $node`;
		$ballRoll = `group -n ($leg+"_ballRoll") $node`;
		xform -ws -piv ($pt.x) ($pt.y) ($pt.z) $ballRoll;
		$ballRollReverse = `group -n ($leg+"_ballRollReverse") $ballRoll`;
		xform -ws -piv ($pt.x) ($pt.y) ($pt.z) $ballRollReverse;
		
		//get the toe pivot
		$toePivot = ($leg+"_toepivotnull");
		
		
		//add attrs to main ctl
		string $footCtl = ($leg+"_IK_Leg");
		addAttr -ln "footRoll"  -at double  -min -10 -max 10 -dv 0 $footCtl;
		addAttr -ln "footRollBlend" -at double -min 1 -max 180 -dv 30 $footCtl;
		addAttr -ln "footRollMin" -at double -dv -70 $footCtl;
		addAttr -ln "footRollMax" -at double -dv 75 $footCtl;
		setAttr -e -keyable true ($footCtl+".footRoll");
		setAttr -e -keyable true ($footCtl+".footRollBlend");
		setAttr -e -keyable true ($footCtl+".footRollMin");
		setAttr -e -keyable true ($footCtl+".footRollMax");
		
		//put the main controls pivot at <side>Leg_joint7
		$node = ($leg+"_joint7");
		$pt = `xform -q -ws -rp $node`;
		xform -ws -rp ($pt.x) ($pt.y) ($pt.z) $footCtl;
		
		//some buffer variables
		string $clamp;
		string $setRange;
		string $reverse;
		
		
		
		//setup heelRoll
		$clamp = `shadingNode -asUtility clamp -n ($leg+"_heelRoll_clamp")`;
		$setRange = `shadingNode -asUtility setRange -n ($leg+"_heelRoll_setRange")`;
		connectAttr -f ($footCtl+".footRoll") ($clamp+".inputR");
		connectAttr -f ($clamp+".outputR") ($setRange+".valueX");
		connectAttr -f ($setRange+".outValueX") ($heelRoll+".rotateX");
		connectAttr -f ($footCtl+".footRollMin") ($setRange+".minX");
		btsmtQuickSetAttr($clamp, {"minR", "maxR"}, {-10.0, 0});
		btsmtQuickSetAttr($setRange, {"maxX", "oldMinX", "oldMaxX"}, {0.0, -10, 0});
		
		//setup toePivot
		$clamp = `shadingNode -asUtility clamp -n ($leg+"_toePivot_clamp")`;
		$setRange = `shadingNode -asUtility setRange -n ($leg+"_toePivot_setRange")`;
		connectAttr -f ($footCtl+".footRoll") ($clamp+".inputR");
		connectAttr -f ($clamp+".outputR") ($setRange+".valueX");
		connectAttr -f ($setRange+".outValueX") ($toePivot+".rotateZ");
		connectAttr -f ($footCtl+".footRollMax") ($setRange+".maxX");
		btsmtQuickSetAttr($clamp, {"minR", "maxR"}, {5.0, 10});
		btsmtQuickSetAttr($setRange, {"minX", "oldMinX", "oldMaxX"}, {0.0, 5, 10});
		
		//setup ballRoll
		$clamp = `shadingNode -asUtility clamp -n ($leg+"_ballRoll_clamp")`;
		$setRange = `shadingNode -asUtility setRange -n ($leg+"_ballRoll_setRange")`;
		string $mult = `shadingNode -asUtility multiplyDivide -n ($leg+"_ballRoll_mult")`;
		connectAttr -f ($footCtl+".footRoll") ($clamp+".inputR");
		connectAttr -f ($clamp+".outputR") ($setRange+".valueX");
		connectAttr -f ($setRange+".outValueX") ($mult+".input1X");
		connectAttr -f ($mult+".outputX") ($ballRoll+".rotateZ");
		connectAttr -f ($footCtl+".footRollBlend") ($setRange+".maxX");
		btsmtQuickSetAttr($clamp, {"minR", "maxR"}, {0.0, 5});
		btsmtQuickSetAttr($setRange, {"minX", "oldMinX", "oldMaxX"}, {0.0, 0, 5});
		setAttr ($mult+".input2X") -1;
		
		//setup ballRollReverse
		$clamp = `shadingNode -asUtility clamp -n ($leg+"_ballRollReverse_clamp")`;
		$setRange = `shadingNode -asUtility setRange -n ($leg+"_ballRollReverse_setRange")`;
		connectAttr -f ($footCtl+".footRoll") ($clamp+".inputR");
		connectAttr -f ($clamp+".outputR") ($setRange+".valueX");
		connectAttr -f ($setRange+".outValueX") ($ballRollReverse+".rotateZ");
		connectAttr -f ($footCtl+".footRollBlend") ($setRange+".maxX");
		btsmtQuickSetAttr($clamp, {"minR", "maxR"}, {5.0, 10});
		btsmtQuickSetAttr($setRange, {"minX", "oldMinX", "oldMaxX"}, {0.0, 5, 10});
	}
	
	
	print ("// yay! foot rolling is coool!\n");
}
global proc btsmtFootRollLocators(int $useDigit) {
	//need to ask for the user to place the locator at the back of the heel
	if (`objExists "btsmtFootRoll_heelLocator"`)
		return;
	
	string $leftLegGuess = "LeftLeg_recompensate";
	if ($useDigit) //Beavan's issue again...
		$leftLegGuess = "LeftLeg"+$useDigit+"_recompensate";
	
	vector $pt = `xform -q -ws -rp $leftLegGuess`;
	string $loc[] = `spaceLocator -p ($pt.x) ($pt.y) ($pt.z) -n "btsmtFootRoll_heelLocator"`;
	CenterPivot;
	
	headsUpMessage -t 5 "Please position the locator at the back of the heel, on the ground";
}
global proc btsmtQuickSetAttr(string $obj, string $attrs[], float $values[]) {
	if (!`objExists $obj`)
		return;
	if (size($attrs) != size($values))
		return;
	
	for ($i = 0; $i < size($attrs); $i++) {
		setAttr ($obj+"."+$attrs[$i]) $values[$i];
	}
}


//====================================================================================================
//SETUP HAND CTLS
global proc btsmtHandCtls() {
	select -cl;
	
	if (size(`ls "LeftThumb*_finger_control2_null"`) > 0) {
		warning ("hand controls have already been setup!");
		return;
	}
	
	string $buffer[];
	string $sides[] = {"Left", "Right"};
	for ($side in $sides) {
		//finger controls
		//number of fingers doesn't matter with the following method
		string $fingerCtls[] = `ls ($side+"*_finger_control")`;
		string $fingerJoint1s[] = `ls ($side+"*_rig_fingerjoint1")`;
		string $fingerJoint2s[] = `ls ($side+"*_rig_fingerjoint2")`;
		
		int $fingerCount = size($fingerCtls);
		
		for ($i = 0; $i < $fingerCount; $i++) {
			string $ctl = $fingerCtls[$i];
			string $joint1 = $fingerJoint1s[$i];
			string $joint2 = $fingerJoint2s[$i];
			vector $pt1 = `xform -q -ws -rp $joint1`;
			vector $pt2 = `xform -q -ws -rp $joint2`;
			
			
			//we're going to use btsmtBreakConnections() to break a list of attributes
			//this actually simplified having to hardcode the input plug names
			string $attrsToBreak[];
			$attrsToBreak = {($joint1+".ry"), ($joint1+".rz"), ($joint2+".rx"), ($joint2+".ry"), ($joint2+".rz")};
			btsmtBreakConnections($attrsToBreak);
			
			
			//create a circle ctl
			float $dist = mag($pt2 - $pt1);
			float $radius = (0.65 * $dist);
			string $circle1[] = `circle -r $radius -nr 1 0 0 -ch 0 -n ($ctl+"2")`;
			string $circle2[] = `circle -r $radius -nr 1 0 0 -ch 0 -n ($ctl+"3")`;
			//parent the circles to eachother, then group them
			string $grp1 = `group -n ($ctl+"2_null") $circle1[0]`;
			string $grp2 = `group -n ($ctl+"3_null") $circle2[0]`;
			$buffer = `parent $grp2 $circle1[0]`;
			$grp2 = $buffer[0];
			//parent top group to the main finger_control
			parent $grp1 $ctl;
			
			//use parentConstraints, then delete them (quick orient to joint macro)
			$buffer = `parentConstraint -weight 1 $joint1 $grp1`;
			delete $buffer[0];
			rotate -r -os -z 180 0 0 $grp1;
			$buffer = `parentConstraint -weight 1 $joint2 $grp2`;
			delete $buffer[0];
			rotate -r -os -z 180 0 0 $grp2;
			
			//use direct connections because orient constraint flickers for some reason...
			string $md1 = `shadingNode -asUtility multiplyDivide -n ($ctl+"2_md")`;
			string $md2 = `shadingNode -asUtility multiplyDivide -n ($ctl+"3_md")`;
			setAttr ($md1+".input2X") -1;
			setAttr ($md1+".input2Y") -1;
			setAttr ($md2+".input2X") -1;
			setAttr ($md2+".input2Y") -1;
			for ($var in {"x", "y", "z"}) {
				connectAttr -f ($circle1[0]+".r"+$var) ($md1+".input1"+`toupper $var`);
				connectAttr -f ($circle2[0]+".r"+$var) ($md2+".input1"+`toupper $var`);
				connectAttr -f ($md1+".output"+`toupper $var`) ($joint1+".r"+$var);
				connectAttr -f ($md2+".output"+`toupper $var`) ($joint2+".r"+$var);
			}
			
			
			//point constrain the ctls to the joints (only needed for Finger Stretch)
			pointConstraint -weight 1 $joint1 $circle1[0];
			pointConstraint -weight 1 $joint2 $circle2[0];
			
			//hide attrs
			for ($attr in {"tx", "ty", "tz", "sx", "sy", "sz", "v"}) {
				setAttr -l 1 -k 0 -cb 0 ($circle1[0]+"."+$attr);
				setAttr -l 1 -k 0 -cb 0 ($circle2[0]+"."+$attr);
			}
			
			//its important that the attrs be deleted after disconnectAttrs otherwise they won't work
			if (`gmatch $ctl "*Thumb*"`)
				catch (`deleteAttr -attribute "Side_to_side" $ctl`);
			else
				catch (`deleteAttr -attribute "SideToSide" $ctl`);
			
			catch (`deleteAttr -attribute "MiddleJoint" $ctl`);
			catch (`deleteAttr -attribute "LastJoint" $ctl`);
		}
	}
	
	select -cl;
	
	
	print ("// yay! finger controls are coool!\n");
}

//====================================================================================================
//SETUP TOE CTLS
global proc btsmtToeCtls() {
	select -cl;
	
	if (size(`ls "LeftToe*_Toe_control2_null"`) > 0) {
		warning ("toe controls have already been setup!");
		return;
	}
	
	string $buffer[];
	string $sides[] = {"Left", "Right"};
	for ($side in $sides) {
		//toe controls
		//number of toes doesn't matter with the following method
		string $toeCtls[] = `ls ($side+"*_Toe_control")`;
		string $toeJoint1s[] = `ls ($side+"*_rig_Toejoint1")`;
		string $toeJoint2s[] = `ls ($side+"*_rig_Toejoint2")`;
		
		int $toeCount = size($toeCtls);
		
		for ($i = 0; $i < $toeCount; $i++) {
			string $ctl = $toeCtls[$i];
			string $joint1 = $toeJoint1s[$i];
			string $joint2 = $toeJoint2s[$i];
			vector $pt1 = `xform -q -ws -rp $joint1`;
			vector $pt2 = `xform -q -ws -rp $joint2`;
			
			
			//we're going to use btsmtBreakConnections() to break a list of attributes
			//this actually simplified having to hardcode the input plug names
			string $attrsToBreak[];
			$attrsToBreak = {($joint1+".ry"), ($joint1+".rz"), ($joint2+".rx"), ($joint2+".ry"), ($joint2+".rz")};
			btsmtBreakConnections($attrsToBreak);
			
			
			//create a circle ctl
			float $dist = mag($pt2 - $pt1);
			float $radius = (0.65 * $dist);
			string $circle1[] = `circle -r $radius -nr 1 0 0 -ch 0 -n ($ctl+"2")`;
			string $circle2[] = `circle -r $radius -nr 1 0 0 -ch 0 -n ($ctl+"3")`;
			//parent the circles to eachother, then group them
			string $grp1 = `group -n ($ctl+"2_null") $circle1[0]`;
			string $grp2 = `group -n ($ctl+"3_null") $circle2[0]`;
			$buffer = `parent $grp2 $circle1[0]`;
			$grp2 = $buffer[0];
			//parent top group to the main Toe_control
			parent $grp1 $ctl;
			
			//use parentConstraints, then delete them (quick orient to joint macro)
			$buffer = `parentConstraint -weight 1 $joint1 $grp1`;
			delete $buffer[0];
			rotate -r -os -z 180 0 0 $grp1;
			$buffer = `parentConstraint -weight 1 $joint2 $grp2`;
			delete $buffer[0];
			rotate -r -os -z 180 0 0 $grp2;
			
			//use direct connections because orient constraint flickers for some reason...
			string $md1 = `shadingNode -asUtility multiplyDivide -n ($ctl+"2_md")`;
			string $md2 = `shadingNode -asUtility multiplyDivide -n ($ctl+"3_md")`;
			setAttr ($md1+".input2X") -1;
			setAttr ($md1+".input2Y") -1;
			setAttr ($md2+".input2X") -1;
			setAttr ($md2+".input2Y") -1;
			for ($var in {"x", "y", "z"}) {
				connectAttr -f ($circle1[0]+".r"+$var) ($md1+".input1"+`toupper $var`);
				connectAttr -f ($circle2[0]+".r"+$var) ($md2+".input1"+`toupper $var`);
				connectAttr -f ($md1+".output"+`toupper $var`) ($joint1+".r"+$var);
				connectAttr -f ($md2+".output"+`toupper $var`) ($joint2+".r"+$var);
			}
			
			
			//point constrain the ctls to the joints (only needed for toe Stretch)
			pointConstraint -weight 1 $joint1 $circle1[0];
			pointConstraint -weight 1 $joint2 $circle2[0];
			
			//hide attrs
			for ($attr in {"tx", "ty", "tz", "sx", "sy", "sz", "v"}) {
				setAttr -l 1 -k 0 -cb 0 ($circle1[0]+"."+$attr);
				setAttr -l 1 -k 0 -cb 0 ($circle2[0]+"."+$attr);
			}
			
			//its important that the attrs be deleted after disconnectAttrs otherwise they won't work
			catch (`deleteAttr -attribute "Side_to_side" $ctl`);
			
			catch (`deleteAttr -attribute "MiddleJoint" $ctl`);
			catch (`deleteAttr -attribute "LastJoint" $ctl`);
		}
	}
	
	select -cl;
	
	
	print ("// yay! toe controls are coool!\n");
}


//====================================================================================================
//Setup Free Moving Arms and/or Legs
global proc btsmtFreeArmsAndLegs(int $arms, int $legs) {
    //Enable free movement of arms in both FK and IK mode
    
    
    //error checking
    //make sure arms and legs exist within the scene and are in the right place
    string $parts[];
    if ($arms)
        $parts[size($parts)] = "Arm";
    if ($legs)
        $parts[size($parts)] = "Leg";
    
    string $sides[] = {"Left", "Right"};
    string $nodes[] = {"rotationisolate", "JOINTS", "RIG"};
    string $upperBody = "Character|Upper_Body";
    string $needs[];
    for ($part in $parts) {
        for ($side in $sides) {
            for ($node in $nodes) {
                $needs[size($needs)] = $upperBody + "|" + $side + $part + "_" + $node;
            }
        }
    }
    
    for ($need in $needs) {
        if (!`objExists $need`) {
            error (" could not find necessary node: "+$need);
        }
    }
    
    
    for ($part in $parts) {
        
        //create group containing both sides
        string $grp = `group -em -n ($part + "s")`;
        //parent to upper body
        $grp = btsmtGetFrom(`parent $grp $upperBody`, 0);
        
        //loop through both sides and make changes
        for ($side in $sides) {
            string $sidePart = $side + $part;
            
            string $joint1 = $sidePart + "_joint1";
            //create orient null node
            string $orient = `group -em -p $grp -n ($sidePart + "_orient")`;
            $orient = btsmtGetFrom(`ls -l -sl`, 0);
            //create circle control
            float $radius = btsmtGetJointDistance( $joint1, ($sidePart + "_joint2") ) * 1.15;
            string $ctl = btsmtGetFrom(`circle -c 0 0 0 -nr 1 0 0 -sw 360 -r $radius -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $sidePart`, 0);
            $ctl = btsmtGetFrom(`parent $ctl $orient`, 0);
            //orient the orients using parent constraint technique
            btsmtParentConstraintOrient( $joint1, $orient );
            //change the color of the control shape
            string $ctlShape = btsmtGetFrom(`listRelatives -c -s $ctl`, 0);
            setAttr ($ctlShape + ".overrideEnabled") 1;
            setAttr ($ctlShape + ".overrideColor") 17;
            
            //hide attrs
			for ($attr in {"v"}) {
				setAttr -l 0 -k 0 -cb 1 ($ctl+"."+$attr);
			}
            
            for ($node in $nodes) {
                $need = $upperBody + "|" + $side + $part + "_" + $node;
                parent $need $ctl;
            }
        }
    }
    
    string $msg;
    if (stringArrayContains("Arm", $parts))
        if (stringArrayContains("Leg", $parts))
            $msg = "arms and legs";
        else
            $msg = "arms";
    else if (stringArrayContains("Leg", $parts))
        $msg = "legs";
    
    print ("// yay! free "+ $msg +" are neato!\n");
}





//====================================================================================================
//Hide All TSM Joints
global proc btsmtHideJoints() {
    //goes through all joints int TSM Character hierarchy and makes them invisible
    //joints are not 'hidden' as that would cause controls to be invisible,
    //but rather set to bounding box mode, effectively making them not seen
    string $char = "Character";
    string $joints[] = `listRelatives -f -ad -typ "joint" $char`;
    int $count;
    for ($joint in $joints) {
        catch(`setAttr ($joint + ".overrideEnabled") 1`);
        catch(`setAttr ($joint + ".overrideLevelOfDetail") 1`);
        $count++;
    }
    print ("//Hid "+$count+" joint(s)\n");
}
global proc btsmtShowJoints() {
    string $char = "Character";
    string $joints[] = `listRelatives -ad -typ "joint" $char`;
    for ($joint in $joints) {
        setAttr ($joint + ".overrideEnabled") 0;
        setAttr ($joint + ".overrideLevelOfDetail") 0;
    }
}




global proc btsmtParentConstraintOrient(string $leader, string $follower) {
    //constrain follower to leader to match position then delete the constraint
    string $const = btsmtGetFrom(`parentConstraint -w 1 $leader $follower`, 0);
    delete $const;
}


global proc btsmtBreakConnections(string $connectAttrs[]) {
    //gets all the input plugs of the attributes and breaks them
	
	for ($attr in $connectAttrs) {
		string $sourceAttr = btsmtGetFrom(`listConnections -s 1 -d 0 -p 1 $attr`, 0);
		catch(`disconnectAttr $sourceAttr $attr`);
	}

}

global proc string btsmtGetFrom(string $array[], int $index) {
	return ($array[$index]);
}

global proc float btsmtGetJointDistance(string $joint1, string $joint2) {
    //Return the distance between two joints in worldspace units
    
    vector $pt1 = `xform -q -ws -rp $joint1`;
    vector $pt2 = `xform -q -ws -rp $joint2`;
    float $dist = mag($pt2 - $pt1);
    
    return $dist;
}





//====================================================================================================
//some procedure fixes for the TSM menu
global proc string[] getControlsForBodyPart(string $part, int $ik)
{
	string $result[];
	
	if (startsWith($part, "Head")) {
		if ($ik == 1)
			$result = {"_Head_IK"};
		else
			$result = {"_Neck", "_FK"};
	} else if (startsWith($part, "LeftArm")) {
		if ($ik == 1)
			$result = {"_Arm_IK", "_Arm_Pole_Vector"};
		else
			$result = {"_Shoulder", "_Upper_Arm", "_Lower_Arm", "_HandTranslate", "_Hand"};
	} else if (startsWith($part, "LeftLeg")) {
		if ($ik == 1)
			$result = {"_Leg_Pole_Vector", "_Standard_Pole_Vector", "_IK_Leg", "_Toe_Pivot", "_Heel_Pivot"};
		else
			$result = {"_Upper_Leg", "_Lower_Leg", "_Foot", "_Toe"};
	} else if (startsWith($part, "RightArm")) {
		if ($ik == 1)
			$result = {"_Arm_IK", "_Arm_Pole_Vector"};
		else
			$result = {"_Shoulder", "_Upper_Arm", "_Lower_Arm", "_HandTranslate", "_Hand"};
	} else if (startsWith($part, "RightLeg")) {
		if ($ik == 1)
			$result = {"_Leg_Pole_Vector", "_Standard_Pole_Vector", "_IK_Leg", "_Toe_Pivot", "_Heel_Pivot"};
		else
			$result = {"_Upper_Leg", "_Lower_Leg", "_Foot", "_Toe"};
	} else if (startsWith($part, "Spine")) {
		if ($ik == 0)
			$result = {"_Pelvis_FK", "_Middle_FK", "_Torso_FK"};
		else
			$result = {"_Torso_IK", "_Middle_IK", "_Pelvis_IK"};
	} else if (startsWith($part, "Tail")) {
		$result = {"_Base_Control", "_Control"};
		
		
		
	} else if (startsWith($part, "RightToe")) {
		$result = {"_Toe_control", "_Toe_control2", "_Toe_control3", "_Toe_IK"};
	} else if (startsWith($part, "LeftToe")) {
		$result = {"_Toe_control", "_Toe_control2", "_Toe_control3", "_Toe_IK"};
	} else if (startsWith($part, "LeftThumb")) {
		$result = {"_finger_control", "_finger_control2", "_finger_control3", "_finger_IK"};
	} else if (startsWith($part, "RightThumb")) {
		$result = {"_finger_control", "_finger_control2", "_finger_control3", "_finger_IK"};
	} else if (startsWith($part, "LeftFinger")) {
		$result = {"_finger_control", "_finger_control2", "_finger_control3", "_finger_IK"};
	} else if (startsWith($part, "RightFinger")) {
		$result = {"_finger_control", "_finger_control2", "_finger_control3", "_finger_IK"};
	}
	/*
	} else if (startsWith($part, "RightToe")) {
		$result = {"_Toe_control", "_middleJoint_control", "_lastJoint_control", "_Toe_IK"};
	} else if (startsWith($part, "LeftToe")) {
		$result = {"_Toe_control", "_middleJoint_control", "_lastJoint_control", "_Toe_IK"};
	} else if (startsWith($part, "LeftThumb")) {
		$result = {"_finger_control", "_middleJoint_control", "_lastJoint_control", "_finger_IK"};
	} else if (startsWith($part, "RightThumb")) {
		$result = {"_finger_control", "_middleJoint_control", "_lastJoint_control", "_finger_IK"};
	} else if (startsWith($part, "LeftFinger")) {
		$result = {"_finger_control", "_middleJoint_control", "_lastJoint_control", "_finger_IK"};
	} else if (startsWith($part, "RightFinger")) {
		$result = {"_finger_control", "_middleJoint_control", "_lastJoint_control", "_finger_IK"};
	}
	*/
	return $result;
}

global proc TSM2_mirrorPose()
{
	string $selection[] = `ls -sl`;
	string $strings[];
	int $count;
	string $bodyPartsToMirror[];
	int $bodyPartsToMirrorCount = 0;
	string $bodyPartTypes[] = {"RightArm", "RightFinger", "RightThumb", "LeftArm", "LeftFinger", "LeftThumb", "RightLeg", "RightToe", "LeftLeg", "LeftToe", "Spine", "Head", "Tail", "TailSeg"};
	string $namespace = "";
	
	if (size($selection) == 0) {
		error "Select the TSM2 Controls for the body parts you want to mirror.";
		return;
	}
	
	for($objWithNamespace in $selection) {
		
		int $isTSM2Control = 0;
		string $bodyPart = "";
		
		$count = `tokenize $objWithNamespace ":" $strings`;
		string $obj = $strings[$count-1];
		
		// Extract the namespace
		$namespace = "";
		if ($count > 1)
			$namespace = $strings[0] + ":";
		
		if ($obj == "Character" || $obj == "Upper_Body")
			continue;
		
		// Figure out which body part this is
		
		$count = `tokenize $obj "_" $strings`;
		if ($count > 1) {
			$bodyPart = $strings[0];
			
			for($i = 0; $i < size($bodyPartTypes); ++$i) {
				if (startsWith($bodyPart, $bodyPartTypes[$i])) {    
					$isTSM2Control = 1;
					break;
				}
			}
		}
		
		if ($isTSM2Control == 0) {
			error "Unknown TSM2 body part - only select TSM2 Controls for the body parts you want to mirror.";
			return;
		} else {
			
			if (stringArrayContains(($namespace + $bodyPart), $bodyPartsToMirror) == 0) {
				$bodyPartsToMirror[$bodyPartsToMirrorCount] = $namespace + $bodyPart;
				++$bodyPartsToMirrorCount;
			}
		}
	}
	
	
	// Now we mirror the body parts, if possible.
	for($bodyPart in $bodyPartsToMirror) {
		
		$count = `tokenize $bodyPart ":" $strings`;
		if ($count > 1) {
			$namespace = $strings[0] + ":";
			$bodyPart = $strings[1];
		}
		
		if (!startsWith($bodyPart, "Right") && !startsWith($bodyPart, "Left")) {
			warning ("Can't mirror " + $bodyPart + " because it's not a right / left body part.");
			continue;
		}
		
		string $otherBodyPart;
		if (startsWith($bodyPart, "Right"))
			$otherBodyPart = ("Left" + `substring $bodyPart 6 (size($bodyPart))`);
		else
			$otherBodyPart = ("Right" + `substring $bodyPart 5 (size($bodyPart))`);

		print $otherBodyPart;
		
		string $controlsToMirror[];
		string $set = ($namespace + $bodyPart + "_Controls");
		string $contents1[] = `sets -q $set`;
		int $ik = 0;
		int $ikMatters = 0;
		
		if (`nodeType $contents1[0]` == "objectSet") {
			$ikMatters = 1;
			// Figure out if IK or FK is enabled on this body part
			$ik = `getAttr ($namespace + "Upper_Body." + $bodyPart + "_FKIK")`;
		}
		
		string $controlsToMirror[] = getControlsForBodyPart($bodyPart, $ik);
		print $controlsToMirror;
		if (`objExists ($namespace + $otherBodyPart + $controlsToMirror[0])` == 0) {
			warning ("Can't mirror " + $bodyPart + " because there's no matching " + $otherBodyPart + ".");
			continue;
		}
		
		if ($ikMatters == 1) {
			if (`getAttr ($namespace + "Upper_Body." + $otherBodyPart + "_FKIK")` != $ik) {
				warning ("Couldn't mirror " + $bodyPart + " onto " + $otherBodyPart + " because one is set to IK and the other is set to FK.");
				continue;
			}
		}
		
		for($control in $controlsToMirror) {
			
			string $fullControl = ($namespace + $bodyPart + $control);
			if (!`objExists $fullControl`)
				continue;
			string $attrs[] = `listAttr -keyable $fullControl`;
			
			for($attr in $attrs) {
				string $type = `getAttr -type ($fullControl + "." + $attr)`;
				if ($type != "doubleLinear" && $type != "doubleAngle" && $type != "double")
					continue;
				
				float $f;
				
				if (`getAttr -keyable ($namespace + $otherBodyPart + $control + "." + $attr)` == 0)
					continue;
				
				$f = `getAttr ($fullControl + "." + $attr)`;
				
				// List of attributes to mirror
				
				if ($attr == "translateX") $f *= -1;
				
				if ($control == "_Leg_Pole_Vector") {
					if ($attr == "rotateZ") $f *= -1;
				}
				if ($control == "_IK_Leg") {
					if ($attr == "rotateY") $f *= -1;
					if ($attr == "rotateZ") $f *= -1;
				}
				if ($control == "_middleJoint_control") {
					if ($attr == "rotateY") $f *= -1;
				}
				if ($control == "_finger_control" || $control == "_Toe_control") {
					if ($attr == "translateX") $f *= -1;
					if ($attr == "translateZ") $f *= -1;
					if ($attr == "rotateX") $f *= -1;
					if ($attr == "rotateY") $f *= -1;
					if ($attr == "Side_to_side") $f *= -1;
				}
				if ($control == "_finger_control2" || $control == "_finger_control3") {
					if ($attr == "rotateX") $f *= -1;
					if ($attr == "rotateY") $f *= -1;
				}
				if ($control == "_finger_IK" || $control == "_Toe_IK") {
					if ($attr == "translateX") $f *= -1;
					if ($attr == "translateZ") $f *= -1;
					if ($attr == "rotateY") $f *= -1;
				}
				if ($control == "_Arm_IK") {
					if ($attr == "translateY") $f *= -1;
					if ($attr == "translateZ") $f *= -1;
				}
				if ($control == "_Upper_Leg") {
					if ($attr == "rotateY") $f *= -1;
				}
				if ($control == "_Foot") {
					if ($attr == "rotateX") $f *= -1;
					if ($attr == "rotateY") $f *= -1;
				}
				
				setAttr ($namespace + $otherBodyPart + $control + "." + $attr) $f;
				
				/*
				// not doing this because it'll happen automatically if autokey is turned on, and that's probably the best way for this
				// to work.
				
				$strings = `listConnections -type "animCurve" -scn true -s true -d false ($namespace + $otherBodyPart + $control + "." + $attr)`;
				if (size($strings) > 0) {
					// We're going to set a keyframe if there's animation on that attribute
					setKeyframe ($namespace + $otherBodyPart + $control + "." + $attr);	
				}
				*/
			}
		}
	}
	
}

global proc TSM2_IKFKSwitch() {
	//TSM FKIK fix. Will work in conjunction with added foot roll from TSM tools in the Dillo shelf
	cycleCheck -e off;
	
	int $i;
	
	string $selNodes[] = `selectedNodes`;
	string $buffer[];
	int $numTokens = 0;
	
	$numTokens = `tokenize $selNodes[0] "|" $buffer`;
	string $theNode = $buffer[$numTokens-1];
	
	string $ns = "";
	$numTokens = `tokenize $theNode ":" $buffer`;
	$theNode = $buffer[ $numTokens-1 ];
	
	//at this point selected control is now the string $theNode
	
	if( $numTokens > 1 )
	{
	for( $i = 0; $i < (size($buffer) - 1); $i++ )
	{
	$ns += $buffer[$i];
	$ns += ":";
	}
	}
	
	$numTokens = `tokenize $theNode "_" $buffer`;
	string $sysPref = $buffer[0];
	
	//example: if RightLeg_IK_Leg is selected, here $sysPref = RightLeg
	
	string $switchAttribute = $sysPref + "_FKIK";
	string $upperBody = $ns + "Upper_Body";
	string $userswitch = $upperBody + "." + $switchAttribute;
	
	//this last chunk creates a string with the upperBody FKIK switch control. ex: RightLeg becomes Upper_Body.RightLeg_FKIK
	
	int $currentMode = `getAttr $userswitch`;
	
	string $controlSet;
	if( $currentMode == 0 )
	{
	$controlSet = $ns + $sysPref + "_IK_Controls";
	}
	else
	{
	$controlSet = $ns + $sysPref + "_FK_Controls";
	}
	
	select $controlSet;
	string $controls[] = `selectedNodes`;
	for( $i = 0; $i < size($controls); $i++ )
	{
	string $control = $controls[$i];
	$numTokens = `tokenize $control "|" $buffer`;
	$control = $buffer[$numTokens-1];
	
	string $switch = $control + "_SWITCH";
	
	if( `objExists $switch` )
	{
	string $tempControlAttributes[] = `listAttr -k $control`;
	string $tempSwitchAttributes[] = `listAttr -k $switch`;
	
	string $removeThese[] = {"footRoll", "footRollBlend", "footRollMin", "footRollMax"};
	
	string $controlAttributes[] = stringArrayRemove($removeThese, $tempControlAttributes);
	string $switchAttributes[] = stringArrayRemove($removeThese, $tempSwitchAttributes);
	
	int $j;
	for( $j = 0; $j < size($controlAttributes); $j++ )
	{
	if( $controlAttributes[$j] == "Reposition" )
	{
	$j++;
	}
	string $attributeToSet = $control + "." + $controlAttributes[$j];
	int $foundAttribute = 0;
	int $k;
	for( $k = 0; $k < size($switchAttributes); $k++ )
	{
	if( $controlAttributes[$j] == $switchAttributes[$k] )
	{
	$foundAttribute = 1;
	string $attributeToGet = $switch + "." + $switchAttributes[$k];
	float $valueOfAttribute = `getAttr $attributeToGet`;
	setAttr $attributeToSet $valueOfAttribute;
	}
	}
	
	if( $foundAttribute == 0 )
	{
	setAttr $attributeToSet 0;
	}
	
	setKeyframe $attributeToSet;
	}
	}
	}
	
	if( $currentMode == 0 )
	{
	$currentMode = 1;
	}
	else
	{
	$currentMode = 0;
	}
	setAttr $userswitch $currentMode;
	setKeyframe $userswitch;
	
	$keytime = `findKeyframe -which previous -attribute $switchAttribute -animation objects $upperBody`;
	$now = `currentTime -query`;
	if( $keytime == $now )
	{
	setKeyframe -time 0 $userswitch;
	$keytime = 0;
	}
	keyTangent -time $keytime -outTangentType step -attribute $switchAttribute - animation objects $upperBody;
	
	cycleCheck -e on;
	select -cl;
}

/*global proc btsmtUpdateTSMMenu() {
//replaces the commands in the tsm2 menu

	string $gMainWindow;
	
	if (`menu -exists TSM2ControlsMenu`) deleteUI -menu TSM2ControlsMenu
	
	menu -to true -label "TSM Controls" -parent $gMainWindow TSM2ControlsMenu;
		menuItem -label "FKIK Switch" -command "source boTSMTools; TSM2_IKFKSwitch;";
		menuItem -label "Refresh Rig" -command "doEnableNodeItems false all; doEnableNodeItems true all;";
		menuItem -label "Mirror Pose" -command "source boTSMTools; TSM2_mirrorPose;";
}*/



