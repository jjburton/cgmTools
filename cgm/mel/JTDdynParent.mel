
global proc int JTDdynParent(string $target, string $listOfParents[], int $transRot, string $advTarget)
{
int $cnt = 0;
int $num = 0;
int $lockRecord[] = {0,0,0,0,0,0,0,0,0};
int $parentLockRecord[] = {0,0,0,0,0,0,0,0,0};
string $enumList;
string $oldEnumList;
string $parent[];
string $newList[];
string $check[];
string $parentCheck[];
string $test[];
string $foundParent[];
string $foundChild[];
string $previousParents[];
string $holder;
string $targetParent = $target;
string $origTarget = $target;


if($target == "") return 0; //the target slot is empty
else //there's a target present
{
	if( size($listOfParents) == 0) //there's a target but nothing in the list, so the user wants to remove the constraints
	{
		JTDdeleteDynParent($target);
		return 1;
	}
	
	//if they are trying to add an advTarget as a regular target
	if( objExists(($target+".childPtr")) ) 
	{
		$foundChild = `listConnections ($target+".childPtr")`;
		error -sl true ("in JTDdynParent: Child is a snap driver for "+$foundChild[0]+", remove the parents and try again");
		return 0;
	}
}

//if translate rotate or scale is locked on the target, store these, unlock and then lock it later when it's under the Dyn group
if(`getAttr -l ($target+".tx")`) { if($transRot == 1) error -sl true "in JTDdynParent: Target translation is locked"; $lockRecord[0] = 1; setAttr -l 0 ($target+".tx");}
if(`getAttr -l ($target+".ty")`) { if($transRot == 1) error -sl true "in JTDdynParent: Target translation is locked"; $lockRecord[1] = 1; setAttr -l 0 ($target+".ty");}
if(`getAttr -l ($target+".tz")`) { if($transRot == 1) error -sl true "in JTDdynParent: Target translation is locked"; $lockRecord[2] = 1; setAttr -l 0 ($target+".tz");}

if(`getAttr -l ($target+".rx")`) { if( ($transRot == 1) || ($transRot == 2) ) error -sl true "in JTDdynParent: Target rotation is locked"; $lockRecord[3] = 1; setAttr -l 0 ($target+".rx");}
if(`getAttr -l ($target+".ry")`) { if( ($transRot == 1) || ($transRot == 2) ) error -sl true "in JTDdynParent: Target rotation is locked"; $lockRecord[4] = 1; setAttr -l 0 ($target+".ry");}
if(`getAttr -l ($target+".rz")`) { if( ($transRot == 1) || ($transRot == 2) ) error -sl true "in JTDdynParent: Target rotation is locked"; $lockRecord[5] = 1; setAttr -l 0 ($target+".rz");}

if(`getAttr -l ($target+".sx")`) { $lockRecord[6] = 1; setAttr -l 0 ($target+".sx");}
if(`getAttr -l ($target+".sy")`) { $lockRecord[7] = 1; setAttr -l 0 ($target+".sy");}
if(`getAttr -l ($target+".sz")`) { $lockRecord[8] = 1; setAttr -l 0 ($target+".sz");}

//if the advTarget slot is filler, there is another object that should recieve the Rt. Click menu
if($target == $advTarget) $advTarget = "";
if( (objExists($advTarget)) && ($advTarget != "") ) 
{
	if(!objExists(($advTarget+".childPtr"))) //make sure that it hasnt already been made an advTarget
	{
		addAttr -ln childPtr -at "message" $advTarget;
		connectAttr -f ($target+".message") ($advTarget+".childPtr");
	}
}

//go through the list of parents and add the attributes as an enum string separaterd by colons
for($parents in $listOfParents)
{
	$enumList += $parents;
	$enumList += ":";
	if($parents == $target) //we matched the target to one of the parents on the list, not good
	{
		error -sl true "in JTDdynParent: Child can not have itself as a parent";
		return 0;
	}	
}

if(!objExists( ($target+".Parent") ) ) //this is a case where the dyn constraint doesnt exist yet
{
	addAttr -ln Parent -at "enum" -en $enumList  $target;
	setAttr -keyable true ($target+".Parent");
	
	if($transRot == 3) //we will also implement a "follow" constraint to detatch rotation inheritance
	{
		addAttr -ln Follow -at "enum" -en $enumList $target;
		setAttr -keyable true ($target+".Follow");
	}
}
else //a dynConstraint already exists, so we only need to modify it, we only want from the list what's not already connected
{
	string $buffer[];
	tokenize $enumList ":" $buffer; //break up the enum string so we can compare the list of parents
	
	while(objExists(($target+".Parent_"+$cnt)))
	{
		$foundParent = `listConnections ($target+".Parent_"+$cnt)`; //these are the parents that already exist
		if(endsWith($foundParent[0], "_DynDriver")) $previousParents[$cnt] = substitute("_DynDriver", $foundParent[0], ""); //for display purposes, the enum shouldnt show the DynDriver postfix
		else $previousParents[$cnt] = $foundParent[0];
		$oldEnumList += ($previousParents[$cnt] +":");
		$cnt++;
	}
	if(size($buffer) < $cnt) 
	{
		//the user wants to remove a parent...now what
		$newList = $buffer;
		$enumList = stringArrayToString($newList, ":"); //put it back together
		addAttr -e -enumName $enumList ($target+".Parent");
		JTDremoveDynParent($target, $previousParents);
	}
	else
	{	
		$newList = stringArrayRemove($previousParents, $buffer); //return a list of parents that have not already been connected
		$enumList = stringArrayToString($newList, ":"); //put it back together
		$enumList = ($oldEnumList+$enumList);
		addAttr -e -enumName $enumList ($target+".Parent");
	}
	$cnt = 0;
	
}

$target = $origTarget; //set it back so the actual target recieves the group

//find out if the control has a parent and make an empty group at the same location

//this is the iterative code to find the correct group it should go up the hierarchy looking for the ideal place to insert the Dynamic Parent group
$parent = `listRelatives -p -typ transform $target`; //find the initial parent of the target
//while(1)
//{
	
	//if($parent[0] != "") $parentCheck = `listRelatives -typ parentConstraint $parent[0]`; //always looking to see if there is already a parent constraint present, as it will impede our constraints
	
	if( objExists( ($parent[0]+".child") ) )//there's already a dyn node on top
	{
		$targetParent = $parent[0];
	}
	
	else if( objExists( ($parent[0]+".dynChild") ) )//there's already a dyn node on top
	{
		if($parent[0] != "") $targetParent = $parent[0];
		//break;
	}
	
	//if(size($parentCheck) != 0) //if there are already parent constraints found, then we want to override them by applying new ones right above the target
	//{
	//	$targetParent = $target;
	//	break;
	//}
	//
	//$holder = $parent[0];
	//if($holder!= "") $parent = `listRelatives -p -typ transform $holder`;	
	//if($parent[0] != "") 
	//{
	//	$check = `listRelatives -c -typ transform $parent[0]`;
	//}
	//if(size($check) > 1) //goes above the parents until it finds a sibling, we dont want to put a new group above a node that has multiple children
	//{
	//	$targetParent = $holder;
	//	break;
	//}
		
	else if($parent[0] == "") //got to the world
	{
		$targetParent = $target;
		//break;
	}
	else 
	{
		$targetParent = $target;
	}
//}

//now that we know what what target group to use, lets make sure that it's unlocked or else it will cause transformations when we put it under a new group
if(`getAttr -l ($targetParent+".tx")`) { $parentLockRecord[0] = 1; setAttr -l 0 ($targetParent+".tx");}
if(`getAttr -l ($targetParent+".ty")`) { $parentLockRecord[1] = 1; setAttr -l 0 ($targetParent+".ty");}
if(`getAttr -l ($targetParent+".tz")`) { $parentLockRecord[2] = 1; setAttr -l 0 ($targetParent+".tz");}

if(`getAttr -l ($targetParent+".rx")`) { $parentLockRecord[3] = 1; setAttr -l 0 ($targetParent+".rx");}
if(`getAttr -l ($targetParent+".ry")`) { $parentLockRecord[4] = 1; setAttr -l 0 ($targetParent+".ry");}
if(`getAttr -l ($targetParent+".rz")`) { $parentLockRecord[5] = 1; setAttr -l 0 ($targetParent+".rz");}

if(`getAttr -l ($targetParent+".sx")`) { $parentLockRecord[6] = 1; setAttr -l 0 ($targetParent+".sx");}
if(`getAttr -l ($targetParent+".sy")`) { $parentLockRecord[7] = 1; setAttr -l 0 ($targetParent+".sy");}
if(`getAttr -l ($targetParent+".sz")`) { $parentLockRecord[8] = 1; setAttr -l 0 ($targetParent+".sz");}

if( !objExists( ($targetParent+".dynChild") ) )
{
	$parent = `listRelatives -p -typ transform $targetParent`;
	if(!objExists( ($targetParent+"_Dyn") ))
	{
		group -em -n ($targetParent+"_Dyn"); //make the empty group that will recieve the constraints
		float $absPos[] = `xform -q -ws -rp $targetParent`; //put its pivot at the same place as the target
		move $absPos[0] $absPos[1] $absPos[2] ($targetParent+"_Dyn.scalePivot") ($targetParent+"_Dyn.rotatePivot");
		
		parent ($targetParent) ($targetParent+"_Dyn"); //put the target's or its parent under the empty group
			
		addAttr -ln parentType -dt "string" $target; //the parent type will indicate if there is a follow control
		setAttr -type "string" ($target+".parentType") $transRot;
		setAttr -l true ($target+".parentType");
		
		addAttr -ln dynChild -at "message" ($targetParent+"_Dyn"); //dyn child is a pointer to the target that was oriignally input, not the group that recieves the constraints
		connectAttr -f ($target+".message") ($targetParent+"_Dyn.dynChild");
		
		addAttr -ln parentGrp -at "message" $target;  //this is a pointer to the group that recieves the constraints, so we can remove it later
		connectAttr -f ($targetParent+"_Dyn.message") ($target+".parentGrp");
		
		//put it back
		if($parent[0] != "") parent ($targetParent+"_Dyn") $parent[0];
	}
	
	if($transRot == 3)
	{
		group -em -n ($target+"_follow");
		float $absPos[] = `xform -q -ws -rp $target`;
		move $absPos[0] $absPos[1] $absPos[2] ($target+"_follow.scalePivot") ($target+"_follow.rotatePivot");
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 ($target+"_follow");
	}
}
else
{
	if( ($transRot == 3) && (!objExists(($target+"_follow"))) )
	{
		group -em -n ($target+"_follow");
		float $absPos[] = `xform -q -ws -rp $target`;
		move $absPos[0] $absPos[1] $absPos[2] ($target+"_follow.scalePivot") ($target+"_follow.rotatePivot");
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 ($target+"_follow");
	}
	
	$parent = `listRelatives -c $targetParent`;
	$targetParent = $parent[0];
}

//make the extra empty group created above a child of the parent, then modify the list of parents to make this group the parent

for($i=0;$i<size($listOfParents);$i++)
{
if( (!objExists($listOfParents[$i]+"_DynDriver")) &&  ($listOfParents[$i] != "")) //if it already exists we dont need to create it again
{
	group -em -n ($listOfParents[$i]+"_DynDriver");
	float $absPos[] = `xform -q -ws -rp $targetParent`;
	move $absPos[0] $absPos[1] $absPos[2] ($listOfParents[$i]+"_DynDriver.scalePivot") ($listOfParents[$i]+"_DynDriver.rotatePivot");
	
	parent ($listOfParents[$i]+"_DynDriver") $listOfParents[$i];
	JTDlockAttrs(($listOfParents[$i]+"_DynDriver"), {1}, {1}, {1}, 1);
	JTDhideAttrs(($listOfParents[$i]+"_DynDriver"), {1}, {1}, {1}, 1);
}
	
}

if(objExists( ($target+"_DynParentCnst") ) ) 
{
	string $weights[];
	if( ($transRot == 1) || ($transRot == 3) ) $num = size(`parentConstraint -q -tl ($target+"_DynParentCnst")`);
	if($transRot == 2) $num = size(`orientConstraint -q -tl ($target+"_DynParentCnst")`);
}

//make a constraint for each parent on the list
for($parents in $listOfParents)
{
	if( (!objExists( ($target+"_"+$parents+"_IfDynParent") ))  &&  ($parents != "") )
	{
		if($transRot == 1) parentConstraint -mo -weight 1 -n ($target+"_DynParentCnst") ($parents+"_DynDriver") ($targetParent+"_Dyn"); //do rotation and translation
		if($transRot == 2) orientConstraint -mo -weight 1 -n ($target+"_DynParentCnst") ($parents+"_DynDriver") ($targetParent+"_Dyn"); //only do rotation
		if($transRot == 3) 
		{
			parentConstraint -mo -weight 1 -n ($target+"_DynParentCnst") ($parents+"_DynDriver") ($target+"_follow"); //do rotation and translation
			orientConstraint -mo -weight 1 -n ($target+"_followOrCnst") ($parents+"_DynDriver") ($targetParent+"_Dyn"); //only do rotation
						
			createNode "condition" -n ($target+"_"+$parents+"_IfFollow");
			setAttr ($target+"_"+$parents+"_IfFollow.operation") 0; //equal
			connectAttr ($target+".Follow")  ($target+"_"+$parents+"_IfFollow.firstTerm");
			setAttr ($target+"_"+$parents+"_IfFollow.secondTerm") $num;
			setAttr ($target+"_"+$parents+"_IfFollow.colorIfTrueR") 1;
			setAttr ($target+"_"+$parents+"_IfFollow.colorIfFalseR") 0;
			connectAttr ($target+"_"+$parents+"_IfFollow.outColorR") ($target+"_followOrCnst.w"+$num);
			
			if( (objExists($advTarget)) && ($advTarget != "") )
			{
				addAttr -ln ("Follow_"+$num) -at "message" $advTarget;
				connectAttr -f ($parents+"_DynDriver.message") ($advTarget+".Follow_"+$num);
			}
			addAttr -ln ("Follow_"+$num) -at "message" $target;
			connectAttr -f ($parents+"_DynDriver.message") ($target+".Follow_"+$num);
		}
		
		createNode "condition" -n ($target+"_"+$parents+"_IfDynParent");
		setAttr ($target+"_"+$parents+"_IfDynParent.operation") 0; //equal
		connectAttr ($target+".Parent")  ($target+"_"+$parents+"_IfDynParent.firstTerm");
		setAttr ($target+"_"+$parents+"_IfDynParent.secondTerm") $num;
		setAttr ($target+"_"+$parents+"_IfDynParent.colorIfTrueR") 1;
		setAttr ($target+"_"+$parents+"_IfDynParent.colorIfFalseR") 0;
		connectAttr ($target+"_"+$parents+"_IfDynParent.outColorR") ($target+"_DynParentCnst.w"+$num);
		
		if( (objExists($advTarget)) && ($advTarget != "") )
		{
			addAttr -ln ("Parent_"+$num) -at "message" $advTarget;
			connectAttr -f ($parents+"_DynDriver.message") ($advTarget+".Parent_"+$num);
		}
		addAttr -ln ("Parent_"+$num) -at "message" $target;
		connectAttr -f ($parents+"_DynDriver.message") ($target+".Parent_"+$num);
	
		$num++;
	}
	
}


if($transRot == 3)
{
	pointConstraint -weight 1 -n ($target+"_followPtCnst")  ($target+"_follow") ($targetParent+"_Dyn");
}

//JTDlockAttrs($targetParent, {1}, {1}, {1}, 1);
//JTDhideAttrs($targetParent, {1}, {1}, {1}, 1);

//JTDlockAttrs(($targetParent+"_Dyn"), {1}, {1}, {1}, 1);
//JTDhideAttrs(($targetParent+"_Dyn"), {1}, {1}, {1}, 1);

//lock it back up
if($lockRecord[0]) setAttr -l 1 ($target+".tx");
if($lockRecord[1]) setAttr -l 1 ($target+".ty");
if($lockRecord[2]) setAttr -l 1 ($target+".tz");
if($lockRecord[3]) setAttr -l 1 ($target+".rx");
if($lockRecord[4]) setAttr -l 1 ($target+".ry");
if($lockRecord[5]) setAttr -l 1 ($target+".rz");
if($lockRecord[6]) setAttr -l 1 ($target+".sx");
if($lockRecord[7]) setAttr -l 1 ($target+".sy");
if($lockRecord[8]) setAttr -l 1 ($target+".sz");

if($parentLockRecord[0]) setAttr -l 1 ($targetParent+".tx");
if($parentLockRecord[1]) setAttr -l 1 ($targetParent+".ty");
if($parentLockRecord[2]) setAttr -l 1 ($targetParent+".tz");
if($parentLockRecord[3]) setAttr -l 1 ($targetParent+".rx");
if($parentLockRecord[4]) setAttr -l 1 ($targetParent+".ry");
if($parentLockRecord[5]) setAttr -l 1 ($targetParent+".rz");
if($parentLockRecord[6]) setAttr -l 1 ($targetParent+".sx");
if($parentLockRecord[7]) setAttr -l 1 ($targetParent+".sy");
if($parentLockRecord[8]) setAttr -l 1 ($targetParent+".sz");

//create the snapping script by overriding the normal right click menu in maya
JTDcreateRtClick();

return 1;
}

global proc int JTDremoveDynParent(string $target, string $removeList[])
{
int $cnt=0;
string $connected[];
string $constraints[];
string $dynDrivers[];
string $connections[];

if( ($target == "") || (!objExists($target)) ) return 0;

if(objExists(($target+".parentGrp")))
{
	$connected = `listConnections ($target+".parentGrp")`;
	$constraints = `listRelatives -typ parentConstraint $connected[0]`;
	for($constrain in $constraints)
	{
		if(endsWith($constrain, "DynParentCnst")) //found the right constraint
		{
			for($remove in $removeList)
			{
				if(objExists( ($target+"_"+$remove+"_IfDynParent") )) delete ($target+"_"+$remove+"_IfDynParent");
			}
			
			delete $constrain;
			
			while(objExists( ($target+".Parent_"+$cnt) ) )
			{
				$dynDrivers = `listConnections ($target+".Parent_"+$cnt)`;
				for($driver in $dynDrivers)
				{
					$connections = `listConnections -type parentConstraint $driver`;
					if(size($connections) == 0) delete $driver;
				}
				setAttr -l 0 ($target+".Parent_"+$cnt);
				deleteAttr ($target+".Parent_"+$cnt);
				$cnt++;
			}
		}
	
	}
	$cnt = 0;
	//removing a follow constraint
	$constraints = `listRelatives -typ pointConstraint -typ orientConstraint $connected[0]`;
	for($constrain in $constraints)
	{
		if( endsWith($constrain, "_followOrCnst") ) //found the right constraint
		{
			for($remove in $removeList)
			{
				if(objExists( ($target+"_"+$remove+"_IfFollow") )) delete ($target+"_"+$remove+"_IfFollow"); //delete the condition nodes
			}
			delete $constrain;
			
			while(objExists( ($target+".Parent_"+$cnt) ) )
			{
				$dynDrivers = `listConnections ($target+".Parent_"+$cnt)`;
				for($driver in $dynDrivers)
				{
					$connections = `listConnections -type parentConstraint $driver`;
					if(size($connections) == 0) delete $driver;
				}
				setAttr -l 0 ($target+".Parent_"+$cnt);
				deleteAttr ($target+".Parent_"+$cnt);
				$cnt++;
			}
			$cnt = 0;
			while(objExists( ($target+".Follow_"+$cnt) ) )
			{
				setAttr -l 0 ($target+".Follow_"+$cnt);
				deleteAttr ($target+".Follow_"+$cnt);
				$cnt++;
			}
		}
		if(endsWith($constrain, "_followPtCnst")) 
		{
			$weights = `pointConstraint -q -tl $constrain`;
			for($weight in $weights)
			{
				if(endsWith($weight, "_follow")) delete $weight;
			}
		}
	}
}
return 1;
}

global proc int JTDdeleteDynParent(string $target)
{
string $parentGrp[];
string $constraints[];
string $weights[];
string $conditionNodes[];
string $dynDrivers[];
string $connections[];

int $cnt = 0;
if( ($target == "") || (!objExists($target)) ) return 0;

if( objExists(($target+".parentGrp")) ) 
{
	//get the group above the target
	$parentGrp = `listConnections ($target+".parentGrp")`;
	//get the master parent constraint
	$constraints = `listRelatives -typ parentConstraint $parentGrp[0]`;
	for($constrain in $constraints)
	{
		//delete the condition nodes attached to the constraint
		if(endsWith($constrain, "DynParentCnst")) 
		{
			$weights = `parentConstraint -q -wal $constrain`;
			for($weight in $weights)
			{
				$conditionNodes = `listConnections ($constrain+"."+$weight)`;
				for($node in $conditionNodes)
				{
					if(endsWith($node, "_IfDynParent")) delete $node;
				}
			}
		}
		delete $constrain;
	}
	//get any constraints created in "follow" mode
	$constraints = `listRelatives -typ pointConstraint -typ orientConstraint $parentGrp[0]`;
	for($constrain in $constraints)
	{
		//delete the condition nodes attached to the constraint
		if(endsWith($constrain, "_followPtCnst")) 
		{
			$weights = `pointConstraint -q -tl $constrain`;
			for($weight in $weights)
			{
				if(endsWith($weight, "_follow")) delete $weight;
			}
		}
		
		if(endsWith($constrain, "_followOrCnst")) 
		{
			$weights = `orientConstraint -q -wal $constrain`;
			for($weight in $weights)
			{
				$conditionNodes = `listConnections ($constrain+"."+$weight)`;
				for($node in $conditionNodes)
				{
					if(endsWith($node, "_IfFollow")) delete $node;
				}
			}
		}
		if(objExists($constrain)) delete $constrain; //sometimes it gets auto-deleted so we have to check for it
	}
	ungroup $parentGrp[0];
}

//now get rid of all the extra attributes
if( objExists(($target+".childPtr")) ) { setAttr -l 0 ($target+".childPtr"); deleteAttr ($target+".childPtr");}
if( objExists(($target+".Parent")) ) { setAttr -l 0 ($target+".Parent"); deleteAttr ($target+".Parent");}
if( objExists(($target+".Follow")) ) { setAttr -l 0 ($target+".Follow"); deleteAttr ($target+".Follow");}
if( objExists(($target+".parentType")) ) { setAttr -l 0 ($target+".parentType"); deleteAttr ($target+".parentType");}
if( objExists(($target+".parentGrp")) ) { setAttr -l 0 ($target+".parentGrp"); deleteAttr ($target+".parentGrp");}

while(objExists(($target+".Parent_"+$cnt)))
{
	$dynDrivers = `listConnections ($target+".Parent_"+$cnt)`;
	for($driver in $dynDrivers)
	{
		$connections = `listConnections -type parentConstraint $driver`;
		if(size($connections) == 0) delete $driver;
	}
	setAttr -l 0 ($target+".Parent_"+$cnt);
	deleteAttr ($target+".Parent_"+$cnt);
	$cnt++;	
}
$cnt = 0;
while(objExists(($target+".Follow_"+$cnt)))
{
	$dynDrivers = `listConnections ($target+".Follow_"+$cnt)`;
	for($driver in $dynDrivers)
	{
		$connections = `listConnections -type parentConstraint $driver`;
		if(size($connections) == 0) delete $driver;
	}
	setAttr -l 0 ($target+".Follow_"+$cnt);
	deleteAttr ($target+".Follow_"+$cnt);
	$cnt++;	
}

return 1;
}


global proc JTDcreateRtClick()
{
int $cnt;
string $cmd;
string $nodes[] = `ls -typ script`;

for($node in $nodes)
{
	if(objExists( ($node+".rtClick") )) //see if one already exists
	{
		$cnt++;
	}
}

if($cnt == 0)
{
	$cmd = JTDgetRtClickMenuScript();
	scriptNode -st 1 -bs $cmd -n "rtClickMenu";
	
	addAttr -ln rtClick -dt "string" rtClickMenu; //add an attribute to test for
	setAttr -type "string" rtClickMenu.rtClick "rtClickMenu";
	setAttr -l true rtClickMenu.rtClick;
	
	$cmd = JTDgetDagMenuScript7();	//this code is based on the code found in the maya scripts and needs to be updated for new versions of Maya
	scriptNode -st 1 -bs $cmd -n "dagMenuProc7";
	
	$cmd = JTDgetDagMenuScript8();	//this code is based on the code found in the maya scripts and needs to be updated for new versions of Maya
	scriptNode -st 1 -bs $cmd -n "dagMenuProc8";
	
	$cmd = JTDgetPivotScripts();
	scriptNode -st 1 -bs $cmd -n "pivotScripts";
	
	scriptNode -eb "rtClickMenu";
	scriptNode -eb "pivotScripts";
}

}

global proc string JTDgetRtClickMenuScript()
{
string $cmd= (

"JTDrunScripts;\n"+
"global proc JTDrunScripts()\n"+
"{\n"+
"string $JTDnameSpace = \"\";\n"+
"string $refs[] = `file -q -r`;\n"+
"for($ref in $refs) \n"+
"{\n"+
"\t$JTDnameSpace = (`file -q -ns $ref` + \":\");\n"+
"\tif(!`objExists(($JTDnameSpace+\"rtClickMenu\"))`) $JTDnameSpace = \"\";\n"+
"}\n"+
"if ((getApplicationVersionAsFloat() >= 7.0) && (getApplicationVersionAsFloat() < 8.0))\n"+
"{\n"+
"\tscriptNode -executeBefore ($JTDnameSpace+\"dagMenuProc7\");\n"+
"}\n"+
"else if ((getApplicationVersionAsFloat() >= 8.0) && (getApplicationVersionAsFloat() < 9.0))\n"+
"{\n"+
"\tscriptNode -executeBefore ($JTDnameSpace+\"dagMenuProc8\");\n"+
"}\n"+
"}\n"+
"global proc JTDdynParentSnap(string $control, int $enum)\n"+
"{\n"+
"float $JTDpos[];\n"+
"float $JTDrot[];\n"+
"int $onOff;\n"+
"$JTDpos = `xform -q -ws -rp $control`;\n"+
"$JTDrot = `xform -q -ws -ro $control`;\n"+
"if(objExists(($control+\".autoStretch\"))) {$onOff = `getAttr ($control+\".autoStretch\")`; setAttr ($control+\".autoStretch\") 0;}\n"+
"setAttr ($control+\".Parent\") $enum;\n"+
"move -a -ws -rpr $JTDpos[0] $JTDpos[1] $JTDpos[2] $control;\n"+
"rotate -a -ws $JTDrot[0] $JTDrot[1] $JTDrot[2] $control;\n"+
"if(objExists(($control+\".autoStretch\"))) setAttr ($control+\".autoStretch\") $onOff;\n"+
"}\n"+
"global proc JTDfollowSnap(string $control, int $enum)\n"+
"{\n"+
"float $JTDrot[];\n"+
"$JTDrot = `xform -q -ws -ro $control`;\n"+
"setAttr ($control+\".Follow\") $enum;\n"+
"rotate -a -ws $JTDrot[0] $JTDrot[1] $JTDrot[2] $control;\n"+
"}\n"+
"proc JTDmatchFKIK(string $JTDswitcher, string $JTDupSW, string $JTDmidSW, string $JTDlowSW, string $JTDupFK, string $JTDmidFK, string $JTDlowFK, string $JTDupIK, string $JTDmidIK)\n"+
"{\n"+
"if(getAttr(($JTDswitcher+\".IKFK\")) != 0){\n"+
"float $upStretch = `getAttr ($JTDupIK+\".stretch\")`;\n"+
"float $midStretch = `getAttr ($JTDmidIK+\".stretch\")`;\n"+
"float $upRot[] = `xform -q -ws -ro $JTDupSW`;\n"+
"float $midRot[] = `xform -q -ws -ro $JTDmidSW`;\n"+
"float $lowRot[] = `xform -q -ws -ro $JTDlowSW`;\n"+
"rotate -a -ws $upRot[0] $upRot[1] $upRot[2] $JTDupFK;\n"+
"rotate -a -ws $midRot[0] $midRot[1] $midRot[2] $JTDmidFK;\n"+
"rotate -a -ws $lowRot[0] $lowRot[1] $lowRot[2] $JTDlowFK;\n"+
"setAttr ($JTDupFK+\".stretch\") $upStretch;\n"+
"setAttr ($JTDmidFK+\".stretch\") ($midStretch);\n"+
"setAttr ($JTDswitcher+\".IKFK\") 0;}\n"+
"select -r $JTDlowFK;\n"+
"}\n"+
"proc JTDmatchIKFK(string $JTDswitcher, string $JTDIKpos, string $JTDIKcntrl, string $JTDPV, string $JTDPVpos)\n"+
"{\n"+
"if(getAttr(($JTDswitcher+\".IKFK\")) != 1){\n"+
"float $lowRot[] = `xform -q -ws -ro $JTDIKpos`;\n"+
"float $lowPos[] = `xform -q -ws -rp $JTDIKpos`;\n"+
"float $midPos[] = `xform -q -ws -rp $JTDPVpos`;\n"+
"float $pivotPos[];\n"+
"if(objExists( ($JTDIKcntrl+\".js_pivotObj\") )) { $pivot = `js_pivot_get $JTDIKcntrl \"js_pivotObj\"`; $pivotPos[0] = `getAttr ($pivot+\".tx\")`; $pivotPos[1] = `getAttr ($pivot+\".ty\")`; $pivotPos[2] = `getAttr ($pivot+\".tz\")`; jd_pivot_reset($JTDIKcntrl);}\n"+
"move -a -ws -rpr $lowPos[0] $lowPos[1] $lowPos[2] $JTDIKcntrl;\n"+
"rotate -a -ws $lowRot[0] $lowRot[1] $lowRot[2] $JTDIKcntrl;\n"+
"move -a -ws -rpr $midPos[0] $midPos[1] $midPos[2] $JTDPV;\n"+
"setAttr ($JTDswitcher+\".IKFK\") 1;\n"+
"if(objExists( ($JTDIKcntrl+\".js_pivotObj\") )) {$pivot = `js_pivot_get $JTDIKcntrl \"js_pivotMovObj\"`; setAttr ($pivot+\".tx\") $pivotPos[0]; setAttr ($pivot+\".ty\") $pivotPos[1]; setAttr ($pivot+\".tz\") $pivotPos[2]; js_pivot_snap($JTDIKcntrl, 0);}\n"+
"}\n"+
"select -r $JTDIKcntrl;\n"+
"}\n"
);

return $cmd;
}


global proc string JTDgetDagMenuScript7()
{
string $cmd = (

"proc optionalDagMenuProc( string $parent, string $item )\n"+
"{\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tstring $shape = \"\";\n"+
"\tint $gotVisible = 0;\n"+
"\tif( size($object) < 1 ) return;\n"+
"\tfor( $i=0; $i<size($object); $i+=1) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor( $i=0; $i<size($object); $i+=1) {\n"+
"\t\t\tif( 0 == getAttr($object[$i] + \".io\")) {\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( \"\" != $shape ) {\n"+
"\t\tstring $nt = `nodeType $shape`;\n"+
"\t\tswitch( $nt ) {\n"+
"\t\t  case \"subdiv\":\n"+
"\t\t\tsubdOptionalDagMenuProc( $parent, $item );\n"+
"\t\t\tmenuItem -d true; \n"+
"\t\t\tbreak;\n"+
"\t\t  default:\n"+
"\t\t\t// Check to make sure we have a kPlugin prefix\n"+
"\t\t\tstring $apiNt = `nodeType -api $shape`;\n"+
"\t\t\tif ( startsWith( $apiNt, \"kPlugin\" ) ) {\n"+
"\t\t\t\tstring $nodeMenuCommand = $nt + \"DagMenuProc\";\n"+
"\t\t\t\tstring $nodeMenuCommandWithArgs = $nodeMenuCommand + \"(\\\"\" + $parent + \"\\\" , \\\"\" + $item + \"\\\" )\";\n"+
"\t\t\t\tif ( exists( $nodeMenuCommand ) ) {\n"+
"\t\t\t\t   eval( $nodeMenuCommandWithArgs );\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"proc int objectIsTrimmed(string $item)\n"+
"// Return true if this is a trimmed surface\n"+
"{\n"+
"\tstring $command = (\"getAttr -size \" + $item + \".trimFace\");\n"+
"\tint $trimCount = eval($command);\n"+
"\treturn ($trimCount != 0);\n"+
"}\n"+
"proc string getControlledHandle(string $item)\n"+
"{\n"+
"\tstring $handle;\n"+
"\tif (size(`ls ($item+\".ikBlend\")`)) {\n"+
"\t\tstring $connHandles[] =\n"+
"\t\t\t`listConnections -type ikHandle ($item+\".ikBlend\")`;\n"+
"\t\tif (size($connHandles)) {\n"+
"\t\t\t$handle = $connHandles[0];\n"+
"\t\t}\n"+
"\t}\n"+
"\treturn $handle;\n"+
"}\n"+
"proc int isIKcontroller(string $item)\n"+
"{\n"+
"\tstring $handle = getControlledHandle($item);\n"+
"\treturn (size($handle) > 0);\n"+
"}\n"+
"proc\n"+
"createFBIKmenuItems(string $parent,\n"+
"\t\t\t\t\tstring $item,\n"+
"\t\t\t\t\tstring $ikReachModeLocation,\n"+
"\t\t\t\t\tstring $keyBodyPartLocation,\n"+
"\t\t\t\t\tstring $keyAllLocation,\n"+
"\t\t\t\t\tstring $keySelectedLocation)\n"+
"{\n"+
"\tstring $reachKeyingMode = \"Reach Mode:\";\n"+
"\tint $rkm = `optionVar -q setIKKey`;\n"+
"\tswitch ($rkm)\n"+
"\t{\n"+
"\t\tcase 1:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" IK\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase 2:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" FK\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase 3:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" Simple\";\n"+
"\t\t\tbreak;\n"+
"\t}\t\n"+
"\tmenuItem -rp $ikReachModeLocation -l $reachKeyingMode\n"+
"\t\t-subMenu true\n"+
"\t\t-annotation \"Determine how reach values get keyed when doing FBIK keying.\";\n"+
"\t\tmenuItem -rp \"S\" -label \"IK (Reach = 1)\"\n"+
"\t\t\t-command FBIKReachKeyingOptionIK;\n"+
"\t\tmenuItem -rp \"N\" -label \"FK (Reach = 0)\"\n"+
"\t\t\t-command FBIKReachKeyingOptionFK;\n"+
"\t\tmenuItem -rp \"E\" -label \"Simple (No Reach)\"\n"+
"\t\t\t-command FBIKReachKeyingOptionSimple;\n"+
"\tsetParent -m $parent;\n"+
"\t\n"+
"\tmenuItem -l \"Key All\"\n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"1\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keyAllLocation\n"+
"\t\tkeyAllItem;\n"+
"\t\n"+
"\tmenuItem -l \"Key Body Part\"\n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"2\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keyBodyPartLocation\n"+
"\t\tkeyBodyPartItem;\n"+
"\t\n"+
"\tmenuItem -l \"Key Selected\"\n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"4\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keySelectedLocation\n"+
"\t\tkeySelectedItem;\n"+
"}\n"+
"proc checkForSkinInfluenceItem(string $item, string $quadrant)\n"+
"{\n"+
"\tint $isJoint = (nodeType($item) == \"joint\");\n"+
"\t\n"+
"\t// Check if the current context is the skinPaint context \n"+
"\t// and the the joint is connected to a skinCluster\n"+
"\t//\n"+
"\tstring  $currContext = `currentCtx`;\n"+
"\tstring  $currTool    = \"\";\n"+
"\tif(`contextInfo -ex $currContext`) {\n"+
"\t\t$currTool = `contextInfo -c $currContext`;\n"+
"\t}\n"+
"\tif ( $currTool == \"artAttrSkin\" ) {\n"+
"\t\tstring $whichTool = `artAttrCtx -q -whichTool $currContext`;\n"+
"\t\tif ( $whichTool == \"skinWeights\" )  {\n"+
"\t\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\t\tstring $conn;\n"+
"\t\t\tfor($conn in $connL) {\n"+
"\t\t\t\tif (`nodeType $conn` == \"skinCluster\")\n"+
"\t\t\t\t{\t\n"+
"\t\t\t\t\t// select the surface (not the joint) and set\n"+
"\t\t\t\t\t// the joint as the current influence\n"+
"\t\t\t\t\t//\n"+
"\t\t\t\t\tstring $currSel[] = `ls -sl`;\n"+
"\t\t\t\t\tstring $currSelString;\n"+
"\t\t\t\t\tif (size($currSel) > 0) {\n"+
"\t\t\t\t\t\tstring $currObj;\n"+
"\t\t\t\t\t\t$currSelString = \"select -r \";\n"+
"\t\t\t\t\t\tfor ($currObj in $currSel) {\n"+
"\t\t\t\t\t\t\t$currSelString += ($currObj+\" \");\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tmenuItem -l \"Paint Weights\"\n"+
"\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t-c ($currSelString+\"; setSmoothSkinInfluence \" + $item)\n"+
"\t\t\t\t\t\t-rp $quadrant\n"+
"\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\t\t// menu for skinCluster paint\n"+
"\telse if ( $isJoint && ($currTool == \"artAttr\") ) {\n"+
"\t\tstring $whichTool = `artAttrCtx -q -whichTool $currContext`;\n"+
"\t\tif ( $whichTool == \"general\" )  {\n"+
"\t\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\t\tstring $conn;\n"+
"\t\t\tfor($conn in $connL) {\n"+
"\t\t\t\tif (`nodeType $conn` == \"jointCluster\")\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\tstring $artCommand = \"artAttrCtx\" ;\n"+
"\t\t\t\t\tstring $attribute = \"cluster.\" + $conn +  \".weights\" ;\n"+
"\t\t\t\t\tmenuItem -l \"Paint Weights\"\n"+
"\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t// the following command doesnot update the UI hence we use the next one\n"+
"\t\t\t\t\t\t//-c (\"artAttrCtx -e -pas \\\"cluster.\" + $conn +  \".weights\\\" `currentCtx`\")\n"+
"\t\t\t\t\t\t-c (\"artSetToolAndSelectAttr( \\\"\" + $artCommand + \"\\\", \\\"\" + $attribute + \"\\\" )\")\n"+
"\t\t\t\t\t\t-rp \"N\"\n"+
"\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// menu for joint-set paint\n"+
"\t// Check if the current context is the setPaint context \n"+
"\t// and the the joint is connected to a objectSet via jointCluster\n"+
"\t//\n"+
"\telse if ( $isJoint && ($currTool == \"artSetPaint\") ) {\n"+
"\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\tstring $conn;\n"+
"\t\tfor($conn in $connL) {\n"+
"\t\t\tif (`nodeType $conn` == \"jointCluster\") {\t\n"+
"\t\t\t\tstring $connS[] = `listConnections ($conn+\".message\")`;\n"+
"\t\t\t\tfor($set in $connS) {\n"+
"\t\t\t\t\tif (`nodeType $set` == \"objectSet\") {\n"+
"\t\t\t\t\t\tmenuItem -l \"Paint Set Membership\"\n"+
"\t\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t\t// the following command doesnot update the UI hence we use the next one\n"+
"\t\t\t\t\t\t\t//-c (\"artSetPaintCtx -e -settomodify \" + $set + \" `currentCtx`\")\n"+
"\t\t\t\t\t\t\t-c (\"artSetPaintSelectSet( \\\"\" + $set + \"\\\" )\")\n"+
"\t\t\t\t\t\t\t-rp \"N\"\n"+
"\t\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\t\tbreak;\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc string[] objectSelectMasks(string $item)\n"+
"// Returns the component selection masks that apply to this object\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tswitch ($nt) {\n"+
"\t\tcase \"lattice\":\n"+
"\t\t\t$maskList[0] = \"latticePoint\";\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"locator\":\n"+
"\t\t\t$maskList[0] = \"locator\";\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"nurbsCurve\":\n"+
"\t\t\t$maskList[0] = \"curveParameterPoint\";\n"+
"\t\t\t$maskList[1] = \"controlVertex\";\n"+
"\t\t\t$maskList[2] = \"editPoint\";\n"+
"\t\t\t$maskList[3] = \"hull\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"nurbsSurface\":\n"+
"\t\t\t$maskList[0] = \"isoparm\";\n"+
"\t\t\t$maskList[1] = \"controlVertex\";\n"+
"\t\t\t$maskList[2] = \"surfaceParameterPoint\";\n"+
"\t\t\t$maskList[3] = \"hull\";\n"+
"\t\t\t$maskList[4] = \"surfaceFace\";\n"+
"\t\t\t$maskList[5] = \"surfaceUV\"; \n"+
"\t\t\tif (objectIsTrimmed($shape)) {\n"+
"\t\t\t\t$maskList[6] = \"surfaceEdge\";\n"+
"\t\t\t}\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"mesh\":\n"+
"\t\t\t$maskList[0] = \"edge\";\n"+
"\t\t\t$maskList[1] = \"vertex\";\n"+
"\t\t\t$maskList[2] = \"facet\";\n"+
"\t\t\t$maskList[3] = \"puv\";\n"+
"\t\t\t$maskList[4] = \"pvf\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"joint\":\n"+
"\t\t\t$maskList[0] = \"joint\";\t\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"ikHandle\":\n"+
"\t\t\t$maskList[0] = \"ikHandle\";\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"hikEffector\":\n"+
"\t\tcase \"hikFloorContactMarker\":\n"+
"\t\t\t$maskList[0] = \"hikEffector\";\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"particle\":\n"+
"\t\t\t$maskList[0] = \"particle\";\t// only one choice\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"spring\":\n"+
"\t\t\t$maskList[0] = \"springComponent\";\t// only one choice\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"subdiv\":\n"+
" \t\t\t$maskList[0] = \"subdivMeshPoint\";\t\n"+
" \t\t\t$maskList[1] = \"subdivMeshEdge\";\t\n"+
" \t\t\t$maskList[2] = \"subdivMeshFace\";\t\n"+
" \t\t\t$maskList[3] = \"subdivMeshUV\";\t\n"+
"\t\t\tbreak;\n"+
"\t}\n"+
"\tif (isIKcontroller($item)) {\n"+
"\t\t$maskList[size($maskList)] = \"ikfkHandle\";\n"+
"\t}\n"+
"\treturn $maskList;\n"+
"}\n"+
"global proc createSelectMenuItems(string $parent, string $item)\n"+
"// Create a menu that shows the dag parenting for this object\n"+
"{\n"+
"\tstring $maskList[] = `objectSelectMasks($item)`;\n"+
"\tstring $radialPosition[];\n"+
"\tstring $uiName;\n"+
"\tint $i;\n"+
"\tint $isNurbObject     = false;\n"+
"\tint $isPolyObject     = false;\n"+
"\tint $isLatticeObject  = false;\n"+
"\tint $isJointObject    = false;\n"+
"\tint $isHikEffector\t  = false;\n"+
"\tint $isIkHandleObject = false;\n"+
"\tint $isIkFkHandleObject = false;\t\n"+
"\tint $isParticleObject = false;\n"+
"\tint $isSpringObject   = false;\n"+
"\tint $isSubdivObject   = false;\n"+
"\tint $isLocatorObject  = false;\n"+
"\tint $hasComponents\t  = false;\n"+
"\tif (1 <= size($maskList)) {\n"+
"\t\t$isLatticeObject = ($maskList[0] == \"latticePoint\");\n"+
"\t\t$isJointObject = ($maskList[0] == \"joint\");\n"+
"\t\t$isHikEffector = ($maskList[0] == \"hikEffector\");\n"+
"\t\t$isIkHandleObject = ($maskList[0] == \"ikHandle\");\n"+
"\t\t$isParticleObject = ($maskList[0] == \"particle\");\n"+
"\t\t$isSpringObject = ($maskList[0] == \"springComponent\");\n"+
"\t\t$isSubdivObject = ($maskList[0] == \"subdivMeshPoint\");\n"+
"\t\t$isLocatorObject = ($maskList[0] == \"locator\");\n"+
"\t}\n"+
"\tif (2 <= size($maskList)) {\n"+
"\t\t$isNurbObject = ($maskList[1] == \"controlVertex\");\n"+
"\t\t$isPolyObject = ($maskList[1] == \"vertex\");\n"+
"\t}\n"+
"\t// $maxRadialPos keeps track of how many octants of the\n"+
"\t// RMB marking menu will be populated\n"+
"\t//\n"+
"\tint $maskSize = size($maskList);\n"+
"\tint $maxRadialPos = size($maskList);\n"+
"\tif (($maskSize > 0) && ($maskList[$maskSize-1] == \"ikfkHandle\")) {\n"+
"\t\t$isIkFkHandleObject = true;\n"+
"\t\t$maxRadialPos--; // ikfkHandle does not populate like other masks\n"+
"\t}\n"+
"\t$hasComponents = $isLatticeObject || \n"+
"\t\t\t\t\t $isParticleObject ||\n"+
"\t\t\t\t\t $isSubdivObject ||\n"+
"\t\t\t\t\t $isSpringObject ||\n"+
"\t\t\t\t\t $isNurbObject ||\n"+
"\t\t\t\t\t $isPolyObject;\n"+
"\t// NOTE: \n"+
"\t//\t\t\tIf the object has selectable components, then the\n"+
"\t//\t\tradial position \"NE\" will be used for the menuItem:  \n"+
"\t//\t\t\"Revert back to object mode.\"\n"+
"\t//\n"+
"\tsetParent -menu $parent;\n"+
"\t$radialPosition[0] = \"N\";\n"+
"\t$radialPosition[1] = \"W\";\n"+
"\t$radialPosition[2] = \"S\";\n"+
"\t$radialPosition[3] = \"E\";\n"+
"\t$radialPosition[4] = \"SW\";\n"+
"\t$radialPosition[5] = \"SE\";\n"+
"\t$radialPosition[6] = \"NW\";\n"+
"\t$radialPosition[7] = \"NE\";\n"+
"\tif ($isNurbObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tswitch ($maskList[$i]) {\n"+
"\t\t\t\tcase \"surfaceParameterPoint\":\n"+
"\t\t\t\t\t$uiName = \"Surface Point\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"curveParameterPoint\":\n"+
"\t\t\t\t\t$uiName = \"Curve Point\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"surfaceEdge\":\n"+
"\t\t\t\t\t$uiName = \"Trim Edge\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"surfaceFace\":\n"+
"\t\t\t\t\t$uiName = \"Surface Patch\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"surfaceUV\":\n"+
"\t\t\t\t\t$uiName = \"UV\";\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\t}\n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuNURBComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tcheckForSkinInfluenceItem($item, \"NW\");\n"+
"\t} else if ($isPolyObject) {\n"+
"\t\t\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tswitch ($maskList[$i]) {\n"+
"\t\t\t  case \"puv\":\n"+
"\t\t\t\t$uiName = \"UV\";\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t  case \"facet\":\n"+
"\t\t\t\t$uiName = \"Face\";\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t  case \"pvf\":\n"+
"\t\t\t\t$uiName = \"Vertex Faces\";\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t  default:\n"+
"\t\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the poly is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"NW\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"NW\");\n"+
"\t} else if ($isLatticeObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuLatticeComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t} else if ($isJointObject) {\n"+
"\t\tstring $setCmd = `performSetPrefAngle 2`;\n"+
"\t\tstring $assumeCmd = `performAssumePrefAngle 2`;\t\t\n"+
"\t\t$setCmd += (\" \"+$item);\n"+
"\t\t$assumeCmd += (\" \"+$item);\n"+
"\t\tstring $jts[] = `ls -sl -type joint`;\n"+
"\t\tfor ($jointItem in $jts) {\n"+
"\t\t\tif ($jointItem != $item) {\n"+
"\t\t\t\t$setCmd += (\" \"+$jointItem);\n"+
"\t\t\t\t$assumeCmd += (\" \"+$jointItem);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tmenuItem -l \"Set Preferred Angle\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c ($setCmd)\n"+
"\t\t\t-rp \"N\"\n"+
"\t\t\tsetPrefAngleItem;\n"+
"\t\t\n"+
"\t\tmenuItem -l \"Assume Preferred Angle\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c ($assumeCmd)\n"+
"\t\t\t-rp \"S\"\n"+
"\t\t\tassumePrefAngleItem;\n"+
"\t\tstring $hikHandle[] = `listConnections -type hikHandle $item`;\n"+
"\t\tint $isFBIKjoint = (size($hikHandle) > 0);\n"+
"\t\tif ($isFBIKjoint) {\n"+
"\t\t\tcreateFBIKmenuItems($parent, $item,\"W\",\"NE\",\"E\",\"SE\");\n"+
"\t\t}\n"+
"\t\t\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the joint is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"N\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"N\");\n"+
"\t} else if ($isHikEffector){\n"+
"\t\tif (nodeType($item) == \"hikFloorContactMarker\") {\n"+
"\t\t\tstring $parentItems[] = `listRelatives -pa -p $item`;\n"+
"\t\t\tif (size($parentItems) &&\n"+
"\t\t\t\tnodeType($parentItems[0]) == \"hikEffector\") {\n"+
"\t\t\t\t$item = $parentItems[0];\n"+
"\t\t\t} else {\n"+
"\t\t\t\t$isHikEffector = false;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tif ($isHikEffector) {\n"+
"\t\t    string $pivotOffsetPlug = $item + \".pivotOffset\";\n"+
"\t\t    float $pivotOffset[] = `getAttr $pivotOffsetPlug`;\n"+
"\t\t    int $enablePin = (equivalentTol($pivotOffset[0],0.0,0.001) &&\n"+
"\t\t                      equivalentTol($pivotOffset[1],0.0,0.001) &&\n"+
"\t\t                      equivalentTol($pivotOffset[2],0.0,0.001));\n"+
"\t\t    \n"+
"\t\t\t// set pinning for hikEffectors\n"+
"\t\t\tmenuItem -l \"Pin Both\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"3\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"N\"\n"+
"\t\t\t\tpinAllItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -l \"Pin Translate\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"1\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"NW\"\n"+
"\t\t\t\tpinTransItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -l \"Pin Rotate\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"2\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"SW\"\n"+
"\t\t\t\tpinRotItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -l \"Unpin\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"0\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-rp \"S\"\n"+
"\t\t\t\tunpinItem;\n"+
"\t\t\t\n"+
"\t\t\tcreateFBIKmenuItems($parent, $item,\"W\",\"NE\",\"E\",\"SE\");\n"+
"\t\t}\n"+
"\t} else if ($isLocatorObject) {\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the joint is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"N\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"N\");\n"+
"\t} else if ($isIkHandleObject) {\n"+
"\t\tmenuItem -l \"Set Preferred Angle\"\n"+
"\t\t\t-annotation \"Set Preferred: Select ikHandles or joints\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (`performSetPrefAngle 2` + \" \" + $item)\n"+
"\t\t\t-rp \"W\"\n"+
"\t\t\tsetPrefAngleItem;\n"+
"\t\tmenuItem -l \"Assume Preferred Angle\"\n"+
"\t\t\t-annotation \"Assume Preferred: Select ikHandles or joints\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (`performAssumePrefAngle 2` + \" \" + $item)\n"+
"\t\t\t-rp \"E\"\n"+
"\t\t\tassumePrefAngleItem;\n"+
"\t\tmenuItem -l \"Enable ikHandle\"\n"+
"\t\t\t-annotation \"Enable IK Handles: Select ikHandles\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -eh \" + $item)\n"+
"\t\t\t-rp \"N\"\n"+
"\t\t\tenableIKHandlesItem;\n"+
"\t\tmenuItem -l \"Disable ikHandle\"\n"+
"\t\t\t-annotation \"Disable IK Handles: Select ikHandles\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -dh \" + $item)\n"+
"\t\t\t-rp \"S\"\n"+
"\t\t\tdisableIKHandlesItem;\n"+
"\t\tmenuItem -l \"Enable Snap\"\n"+
"\t\t\t-annotation \"Enable IK Handle Snapping: Select ikHandles\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -see \" + $item + \";\" +\n"+
"\t\t\t\t\"ikHandle -e -shf on \" + $item)\n"+
"\t\t\t-rp \"SE\"\n"+
"\t\t\tenableIKHandlesSnapItem;\n"+
"\t\tmenuItem -l \"Disable Snap\"\n"+
"\t\t\t-annotation \"Disable IK Handle Snapping: Select ikHandles\"\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -shf off \" + $item)\n"+
"\t\t\t-rp \"SW\"\n"+
"\t\t\tdisableIKHandlesSnapItem;\n"+
"\t\t$maxRadialPos = 6;\n"+
"\t} else if ($isParticleObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tswitch ($maskList[$i]) {\n"+
"\t\t\t\tcase \"particle\":\n"+
"\t\t\t\t\t$uiName = \"Particle\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\t}\n"+
"\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuParticleComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} else if ($isSpringObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tswitch ($maskList[$i]) {\n"+
"\t\t\t\tcase \"springComponent\":\n"+
"\t\t\t\t\t$uiName = \"Spring\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\t}\n"+
"\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuSpringComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} else if ($isSubdivObject) {\n"+
"\t\tsubdDagMenuProc( 0, $item, $maskList );\n"+
"\t} else {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tif ($maskList[$i] == \"ikfkHandle\") {\n"+
"\t\t\t\tcontinue;\n"+
"\t\t\t}\n"+
"\t\t\t\n"+
"\t\t\t$uiName = `interToUI $maskList[$i]`;\n"+
"\t\t\tmenuItem -l $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} \n"+
"\t// If components are present, provide the ability to \n"+
"\t// get back to object mode...\n"+
"\t//\n"+
"\tif ($hasComponents) {\n"+
"\t\tmenuItem -l \"Object Mode\"\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"hilite -unHilite \" + $item + \"; string $selection[] = `ls -sl`;\"\n"+
"\t\t\t\t\t+ \"changeSelectMode -object; select -r $selection;\" )\n"+
"\t\t\t\t-rp \"NE\";\n"+
"\t}\n"+
"\t// Since any object can be an ikfk handle, we only populate the ikfk items\n"+
"\t// in slots that are not already in use.\n"+
"\t//\n"+
"\tif ($isIkFkHandleObject) {\n"+
"\t\tstring $handle = getControlledHandle($item);\n"+
"\t\tif ($maxRadialPos < 8) {\n"+
"\t\t\tmenuItem -label \"Set IK/FK Key\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-annotation \"Set keys on selected joint chains and handles.\"\n"+
"\t\t\t\t-rp $radialPosition[7]\n"+
"\t\t\t\t-command (\"select -r \"+$item+\"; SetIKFKKeyframe\");\n"+
"\t\t}\n"+
"\t\tif ($maxRadialPos < 7) {\n"+
"\t\t\tmenuItem -label \"Move IK to FK\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-annotation \"Select an IK handle or IK/FK connected object.\"\n"+
"\t\t\t\t-rp $radialPosition[6]\n"+
"\t\t\t\t-command (\"select -r \"+$item+\"; MoveIKtoFK\");\n"+
"\t\t}\n"+
"\t\tif ($maxRadialPos < 5) {\n"+
"\t\t\tmenuItem -l \"Disable ikHandle\"\n"+
"\t\t\t\t-annotation \"Disable IK Handle\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"ikHandle -e -dh \" + $handle)\n"+
"\t\t\t\t-rp $radialPosition[5];\n"+
"\t\t\tmenuItem -l \"Enable ikHandle\"\n"+
"\t\t\t\t-annotation \"Enable IK Handle\"\n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"ikHandle -e -eh \" + $handle)\n"+
"\t\t\t\t-rp $radialPosition[4];\n"+
"\t\t}\n"+
"\t}\n"+
"\t\n"+
"\t\n"+
"//\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"//       $itemName = \"SELM\" + string($i);\n"+
"//\t\t\tsetParent -menu $parent;\n"+
"//\t\t\tmenuItem\n"+
"//\t\t\t\t-c (\"doMenuComponentSelection(\\\"\" + \n"+
"//\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"//\t\t\t\t-l $maskList[$i]\n"+
"//\t\t\t\t-rp $radialPosition[$i]\n"+
"//\t\t\t\t$itemName;\n"+
"//\t}\n"+
"\tsetParent -menu $parent;\n"+
"}\n"+
"global proc doMenuNURBComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of NURB components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t//\n"+
"\t\tif( $mask == \"surfaceUV\" )\n"+
"\t\t{\n"+
"\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t{\n"+
"\t\t\t\tstring $warn = \"Edit UV Mode is not enabled on \";\n"+
"\t\t\t\t$warn += $item;\n"+
"\t\t\t\t$warn += \". UVs will not be selectable.\";\n"+
"\t\t\t\twarning($warn);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t} else {\n"+
"\t\tselectType -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -isoparm 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"surfaceUV\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -uv \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\"; \n"+
"\t\t\t\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t\t\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t\t\t\t//\n"+
"\t\t\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\tstring $warn = \"Edit UV Mode is not enabled on \";\n"+
"\t\t\t\t\t\t$warn += $item;\n"+
"\t\t\t\t\t\t$warn += \". UVs will not be selectable.\";\n"+
"\t\t\t\t\t\twarning($warn);\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tbreak; \n"+
"\t\t\t\tcase \"editPoint\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"controlVertex\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"hull\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item + \";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t\t//\n"+
"\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t{\n"+
"\t\t\t\tstring $warn = \"Edit UV Mode is not enabled on \";\n"+
"\t\t\t\t$warn += $item;\n"+
"\t\t\t\t$warn += \". UVs will not be selectable.\";\n"+
"\t\t\t\twarning($warn);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuLatticeComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Changes the selection/display state on this object to allow\n"+
"// selection of the Lattice control points\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (!`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"toggle -\" + $mask + \";\"; \n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuParticleComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of particle\n"+
"// components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -particle 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"particle\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -particle \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuSpringComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of spring\n"+
"// components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -springComponent 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"springComponent\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -springComponent \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Changes the selection/display state on this object to allow\n"+
"// selection of the specified selection mask type.\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (!`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc undoMenuComponentSelection(string $item, string $mask)\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" false;\";\n"+
"\t} else {\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" false;\";\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc toggleBoundingBoxDisplay ( string $parent )\n"+
"//\n"+
"// For each shape under the selected parent object, toggle the\n"+
"// state of bounding box display mode.\n"+
"//\n"+
"{\n"+
"\tstring $shapes[] = `listRelatives -shapes $parent`;\n"+
"\tstring $shape;\n"+
"\tfor ( $shape in $shapes ) {\n"+
"\t\tint $overrideOn = `getAttr ( $shape + \".overrideEnabled\")`;\n"+
"\t\tint $lodMode =    `getAttr ( $shape + \".overrideLevelOfDetail\")`;\n"+
"\t\tint $enabled =     $overrideOn && $lodMode == 1;\n"+
"\t\tif ( $enabled ) {\n"+
"\t\t\t// Don't reset the overrideEnabled attribute. It\n"+
"\t\t\t// is used for more than just bounding box display\n"+
"\t\t\t// and turning if off will mess things up of you\n"+
"\t\t\t// have temporarily enabled bounding box display \n"+
"\t\t\t// of an object in a layer.\n"+
"\t\t\tsetAttr ( $shape + \".overrideLevelOfDetail\" ) 0;\n"+
"\t\t} else {\n"+
"\t\t\tsetAttr ( $shape + \".overrideEnabled\") 1;\n"+
"\t\t\tsetAttr ( $shape + \".overrideLevelOfDetail\") 1;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc createActionsMenuItems(string $parent, string $item)\n"+
"//\n"+
"// Creates a menu with common operations to perform on an object\n"+
"//\n"+
"{\t\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tmenuItem -l \"Template\" -c (\"toggle -template -state on \" + $item);\n"+
"\tmenuItem -l \"Untemplate\" -c (\"toggle -template -state off \" + $item);\n"+
"\tmenuItem -l \"Unparent\" -c (\"parent -w \" + $item);\n"+
"\tmenuItem -l \"Bounding Box\" -c (\"toggleBoundingBoxDisplay \" + $item);\n"+
"}\n"+
"global proc showSG(string $item)\n"+
"{\n"+
"\t//check selection list for faces (polys, subds, nurbs)\n"+
"\tstring $shader = \"\";\n"+
"\tstring $selection[] = `filterExpand -sm 34 -sm 38 -sm 72`;\n"+
"\t// If there are components selected, try to find a component shader\n"+
"\tif( size( $selection ) > 0)\n"+
"\t{\n"+
"\t\tstring $nameBuffer[];\n"+
"\t\tint $numComps = size( $selection );\n"+
"\t\tint $comp;\n"+
"\t\tfor( $comp = 0; $comp < $numComps; $comp++)\n"+
"\t\t{\n"+
"\t\t\ttokenize $selection[ $comp] \".\" $nameBuffer;\n"+
"\t\t\t//if the selected component is on the object under the pointer\n"+
"\t\t\t//get it's shader\n"+
"\t\t\tif ($nameBuffer[0] == $item) {\n"+
"\t\t\t\t$shader = `getComponentShader $selection[$comp]`;\n"+
"\t\t\t\t//check if the shader is already selected - only toggle\n"+
"\t\t\t\t//selection if it is not selected\n"+
"\t\t\t\tstring $shaderSelected[] = `ls -selection $shader`;\n"+
"\t\t\t\tif ( size( $shaderSelected ) == 0){\n"+
"\t\t\t\t\tselect -tgl $shader;\n"+
"\t\t\t\t\n"+
"\t\t\t\t}\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// If we didn't find a component level shader, try for an object level one\n"+
"\tif( size( $shader ) == 0 ) {\n"+
"\t\tstring $allNodes[] = (`listHistory -f true $item` );\n"+
"\t\tstring $node = \"\";\n"+
"\t\tfor ($node in $allNodes) {\n"+
"\t\t\tif(`nodeType $node` == \"shadingEngine\") {\n"+
"\t\t\t\t$shader = $node;\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// If we found a shader, show it\n"+
"\tif( size( $shader ) > 0) \n"+
"\t{\n"+
"\t\tshowEditor $shader;\n"+
"\t}\n"+
"}\n"+
"\t\n"+
"global proc showBakeSets(string $item, string $type)\n"+
"{\n"+
"\tstring $possibleBakeSets[] = (`listHistory -f true $item` );\n"+
"\tstring $node = \"\";\n"+
"    int $bakeSetExists = false;\n"+
"\tfor ($node in $possibleBakeSets) {\n"+
"\t\tif(`nodeType $node` == $type)\n"+
"        {\n"+
"\t\t\tshowEditor $node;\n"+
"            $bakeSetExists = true;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"    // If no bake set exists for the $item, then create the\n"+
"    // initial bake set of that $type and assign it to the $item.\n"+
"    //\n"+
"    if (!$bakeSetExists)\n"+
"    {\n"+
"        string $initialBakeSet = \"\";\n"+
"\t\tif($type == \"vertexBakeSet\") \n"+
"        {\n"+
"            $initialBakeSet = \"initialVertexBakeSet\";\n"+
"        }\n"+
"        else if($type == \"textureBakeSet\") \n"+
"        {\n"+
"            $initialBakeSet = \"initialTextureBakeSet\";\n"+
"\t\t}\n"+
"        else\n"+
"        {\n"+
"            error   -showLineNumber true\n"+
"                (\"Bake set type \"+$type + \" does not exist.\");\n"+
"            return;\n"+
"        }\n"+
"        // Create it if it does not exist yet.\n"+
"        //\n"+
"        if  ( size(`ls $initialBakeSet`) < 1)\n"+
"        {\n"+
"            createBakeSet($initialBakeSet, $type);\n"+
"        } \n"+
"    \n"+
"        // Assign the initial bake set to the item.\n"+
"        //\n"+
"        assignBakeSet($initialBakeSet, $item);\n"+
"        // Show the initial bake set.\n"+
"        //\n"+
"        showBakeSetAE($initialBakeSet);\n"+
"    }\n"+
"}\n"+
"global proc createShaderMenuItems(string $parent, string $item)\n"+
"{\n"+
"\tpopupMenu -e -deleteAllItems $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tmenuItem -l \"Material Attributes...\" -c (\"showSG \" + $item);\n"+
"\tmenuItem -d true;\n"+
"\tbuildShaderMenus($item);\n"+
"}\n"+
"global proc refreshBakingAttributeMenu (string $parent, string $item)\n"+
"{\n"+
"    setParent -menu $parent;\n"+
"    int $suitable = bakeSetTypeSuitableForItem(\"textureBakeSet\", $item);\n"+
"    menuItem -edit -enable $suitable textureBakingAttributeItem;\n"+
"    $suitable = bakeSetTypeSuitableForItem(\"vertexBakeSet\", $item);\n"+
"    menuItem -edit -enable $suitable vertexBakingAttributeItem;\n"+
"}\n"+
"// Description:  This procedure is called to create the \n"+
"//  baking attribute menu.\n"+
"//\n"+
"proc createBakingAttributeMenu(string $parent, string $item)\n"+
"{\n"+
"    setParent -menu $parent;\n"+
"\tmenuItem -l \"Edit Attributes...\" \n"+
"        -subMenu true\n"+
"        -tearOff true\n"+
"        -postMenuCommand (\"refreshBakingAttributeMenu \\\"\"\n"+
"                            +$parent+\"|editAttributeItem\\\" \\\"\"\n"+
"                            +$item+\"\\\"\")\n"+
"        editAttributeItem; \n"+
"        menuItem -l \"texture\" \n"+
"            -c (\"showBakeSets \\\"\"+$item+\"\\\" \\\"textureBakeSet\\\"\") \n"+
"            textureBakingAttributeItem;\n"+
"        menuItem -l \"vertex\" \n"+
"            -c (\"showBakeSets \\\"\"+$item+\"\\\" \\\"vertexBakeSet\\\"\") \n"+
"            vertexBakingAttributeItem;\n"+
"    setParent -menu ..;\n"+
"}\n"+
"// Description:  This procedure is called to create the baking\n"+
"//  menu items.\n"+
"//\n"+
"global proc createBakingMenuItems(string $parent, string $item)\n"+
"//\n"+
"//\tCreate the Baking menus for the RMB popup menu.\n"+
"//\n"+
"{\n"+
"\tpopupMenu -e -deleteAllItems $parent;\n"+
"\tsetParent -menu $parent;\n"+
"    createBakingAttributeMenu($parent, $item);\n"+
"\tmenuItem -d true;\n"+
"\tif (!`about -evalVersion`) {\n"+
"\t\tbuildBakingMenus($item);\n"+
"\t}\n"+
"}\n"+
"// Description:  This procedure is called to create the switch proxy\n"+
"//  menu items.\n"+
"//\n"+
"global proc createSwitchProxyMenuItems(string $parent, string $item, string $refNode)\n"+
"//\n"+
"//\tCreate the switch proxy submenu for the RMB popup menu.\n"+
"//\n"+
"{\n"+
"\tpopupMenu -e -deleteAllItems $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $proxyNodes[] = `getRelatedProxies $refNode`;\n"+
"\tint $i;\n"+
"\tstring $proxyLabel;\n"+
"\tstring $proxyTag;\n"+
"\tfor( $i=0; $i<size($proxyNodes); $i+=1) {\n"+
"\t\t$proxyTag = `getAttr ($proxyNodes[$i] + \".proxyTag\")`;\n"+
"\t\t\n"+
"\t\tmenuItem -l $proxyTag -c (\"proxySwitch \" + $proxyNodes[$i]);\n"+
"\t}\n"+
"}\n"+
"global proc createHistoryMenuItems(string $parent, string $item)\n"+
"//\n"+
"// Creates a menu on the toolbar that shows a list of\n"+
"// all operations that took place to create/modify\n"+
"// the currently selected object.  Note that the list\n"+
"// is not being filtered yet to get rid of things that\n"+
"// users won't really care about, nor are the operations\n"+
"// being listed as operations - their DG node names are\n"+
"// simply being stuck into the menu.  This should\n"+
"// change.\n"+
"//\n"+
"// Also note that the chain of operations limit is being\n"+
"// hardcoded to 20 here, for the sake of speed.\n"+
"//\n"+
"{\n"+
"\t//\n"+
"\t// Delete all menu entries currently in the popup\n"+
"\t//\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\thistoryPopupFill( $item, false, 1 );\n"+
"}\n"+
"global proc createFutureMenuItems(string $parent, string $item)\n"+
"//\n"+
"// Also note that the chain of operations limit is being\n"+
"// hardcoded to 20 here, for the sake of speed.\n"+
"//\n"+
"{\n"+
"\t//\n"+
"\t// Delete all menu entries currently in the popup\n"+
"\t//\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\thistoryPopupFill( $item, true, 1 );\n"+
"}\n"+
"global proc string objectHandlesUvSets(string $item)\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tif ($nt == \"mesh\")\t\n"+
"\t\treturn $shape;\n"+
"\treturn \"\";\n"+
"}\n"+
"global proc createUVsetMenuItems(string $parent, string $item,\n"+
"\t\t\t\t\t\t\t\t string $shape)\n"+
"{\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $cmd = \"polyUVSet -currentUVSet -uvSet \";\n"+
"\tstring $curSet[] = `polyUVSet -q -currentUVSet $shape`;\n"+
"\tstring $names[] = `polyUVSet -q -auv $shape`;\n"+
"\tstring $allProjects[] = `polyUVSet -pr -q $shape`;\n"+
"\tstring $setClearCmd = \"\";\n"+
"\tif (size($allProjects))\n"+
"\t{\n"+
"\t\t$setClearCmd = \"select -d \";\t\t\n"+
"\t\tfor ($p=0; $p<size($allProjects); $p++)\n"+
"\t\t\t$setClearCmd += (\" \" + $allProjects[$p]);\n"+
"\t\t$setClearCmd += \";\";\n"+
"\t}\n"+
"\tint $numNames = size($names);\n"+
"\t// Add in a menu to do uv-linking\n"+
"\tif ($numNames > 0)\n"+
"\t{\t\n"+
"\t\tstring $ann = `getRunTimeCommandAnnotation \"UVCentricUVLinkingEditor\"`;\n"+
"\t\tstring $cmd = \"UVCentricUVLinkingEditor; \" + \"select -r \" + $item;\n"+
"\t\tmenuItem -l \"UV Linking...\"\n"+
"\t\t\t-c $cmd\n"+
"\t\t\t-annotation $ann;\n"+
"\t\tmenuItem -divider true;\n"+
"\t}\n"+
"\tfor ($i=0; $i<$numNames; $i++)\n"+
"\t{\n"+
"\t\tstring $uvEditname = (\"\\\"\" + $names[$i] + \"\\\"\");\n"+
"\t\tstring $uvname = $names[$i];\n"+
"\t\tstring $setCurCmd = $cmd + $uvEditname + \" \" + $shape + \";\";\n"+
"\t\t// Find any projections associated with the uvset\n"+
"\t\tstring $projs[];\n"+
"\t\t$projs = `polyUVSet -pr -uvs $uvname -q $shape`;\n"+
"\t\tstring $projCmd;\n"+
"\t\t// Add a divider between items\n"+
"\t\tif ($i > 0)\n"+
"\t\t\tmenuItem -divider true;\n"+
"\t\tif ($uvname == $curSet[0])\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l ($uvname) -c $setClearCmd -checkBox true;\n"+
"\t\t\tfor ($j=0; $j<size($projs); $j++)\n"+
"\t\t\t{\n"+
"\t\t\t\t$projCmd = ($setClearCmd + \"select -add \"+ $projs[$j] + \";setToolTo ShowManips;\"); \n"+
"\t\t\t\tmenuItem -l $projs[$j] -c $projCmd;\n"+
"\t\t\t\tif ($j >= 5)\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\telse\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l ($uvname) -c ($setClearCmd + $setCurCmd) -checkBox false;\n"+
"\t\t\tfor ($j=0; $j<size($projs); $j++)\n"+
"\t\t\t{\n"+
"\t\t\t\t$projCmd = ($setCurCmd + $setClearCmd + \"select -add \"+ $projs[$j] + \";setToolTo ShowManips;\"); \n"+
"\t\t\t\tmenuItem -l $projs[$j] -c $projCmd;\n"+
"\t\t\t\tif ($j >= 5)\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"//\n"+
"global proc string objectHandlesColorSets(string $item)\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tif ($nt == \"mesh\")\t\n"+
"\t\treturn $shape;\n"+
"\treturn \"\";\n"+
"}\n"+
"global proc createColorSetMenuItems(string $parent, string $item,\n"+
"\t\t\t\t\t\t\t\t string $shape)\n"+
"{\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $cmd = \"polyColorSet -currentColorSet -colorSet \";\n"+
"\tstring $curSet[] = `polyColorSet -q -currentColorSet $shape`;\n"+
"\tstring $names[] = `polyColorSet -q -acs $shape`;\n"+
"\tint $numNames = size($names);\n"+
"\t// Add in a menu to access color set editor\n"+
"\tmenuItem -l \"Color Set Editor...\"\n"+
"\t\t-ann (getRunTimeCommandAnnotation(\"ColorSetEditor\"))\n"+
"\t\t-command \"colorSetEditor\"\n"+
"\t\t;\n"+
"\tif ($numNames > 0)\n"+
"\t{\t\n"+
"\tmenuItem -divider true;\n"+
"\t}\n"+
"\tfor ($i=0; $i < $numNames; $i++)\n"+
"\t{\n"+
"\t\tstring $colorEditname = (\"\\\"\" + $names[$i] + \"\\\"\");\n"+
"\t\tstring $colorname = $names[$i];\n"+
"\t\tstring $setCurCmd = $cmd + $colorEditname + \" \" + $shape + \";\";\n"+
"\t\t// Add a divider between items\n"+
"\t\tif ($i > 0)\n"+
"\t\t\tmenuItem -divider true;\n"+
"\t\tif ($colorname == $curSet[0])\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l ($colorname) -checkBox true;\n"+
"\t\t}\n"+
"\t\telse\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l ($colorname) -c ($setCurCmd) -checkBox false;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc createArtAttrMenuItems(\n"+
"\tstring \t\t$parent, \n"+
"\tstring \t\t$item\n"+
")\n"+
"//\n"+
"//\tDescription:\n"+
"// \t\tCreates a menu that shows all the paintable attributes.\n"+
"// \n"+
"//\tNOTE: paintAttr are sorted by the paintable node type.\n"+
"// \n"+
"{\t\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\t\n"+
"\t// add default items which are always displayed in the context menu\n"+
"\tmenuItem -p $parent -label \"Paint Select\" -command \"ArtPaintSelectToolOptions\" ;\n"+
"\tmenuItem -p $parent -label \"3D Paint\" -command \"Art3dPaintToolOptions\" ;\n"+
"\tmenuItem -p $parent -label \"Sculpt\" -command \"SculptGeometryToolOptions\" ;\n"+
"\t// Get all paintable attributes\n"+
"\tstring $paintAttr = `artBuildPaintMenu $item`;\n"+
"\t\n"+
"\tif ($paintAttr != \"\")\n"+
"\t{\n"+
"\t\t// if the menu item has not been created, create it.\n"+
"\t\tif( $parent == \"\" )\n"+
"\t\t\t$parent = `menuItem -subMenu true -aob true -l \"Paint\"`;\n"+
"\t\t\t\n"+
"\t\n"+
"\t\t// Create the menu.\n"+
"\t\tartAttrCreateMenuItems( $parent, $paintAttr );\n"+
"\t\t\n"+
"\t\t// artAttrCreateMenuItems currently does not use $object\n"+
"\t\t// hence we are making a seperate call to this function to handle\n"+
"\t\t// cloth objects. We need the object name to select the object and detect \n"+
"\t\t// dynamic attributes available for painting.\n"+
"\t\t//\n"+
"\t\tcreatePaintingMenuItems( $parent, $item );\n"+
"\t}\n"+
"}\n"+
"// This has been called because a menu press happened on a DAG object\n"+
"// So find the Object submenu and add the DAG specific items to it.\n"+
"//\n"+
"global proc dagMenuProc(string $parent, string $object)\n"+
"{\n"+
"\tglobal string $artSelectObject ;\n"+
"\tstring $mode = \"All\";\n"+
"\tif (`optionVar -exists currentMenuBarTab`) {\n"+
"\t\t$mode = `optionVar -q currentMenuBarTab`;\n"+
"\t} else {\n"+
"\t\toptionVar -sv currentMenuBarTab $mode;\n"+
"\t}\n"+
"\tif (`popupMenu -e -exists $parent`) {\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t// label the object\n"+
"\t\tstring $shortName = `substitute \".*|\" $object \"\"`;\n"+
"\t\tmenuItem -l ($shortName + \"...\") -c (\"showEditor \"+$object);\n"+
"\t\tmenuItem -divider true;\n"+
"\t\tmenuItem -divider true;\n"+
"\t\t// Create the list of selection masks\n"+
"\t\tcreateSelectMenuItems($parent, $object);\n"+
"\t\tmenuItem -d true;\n"+
"\t\tmenuItem -l \"Select\" -c (\"select -r \" + $object);\n"+
"\t\tmenuItem -l \"Select Hierarchy\" -c (\"select -hierarchy \" + $object);\n"+
"\t\tmenuItem -d true;\n"+
"\t\tif( (objExists(($object+\".Parent\"))) || (objExists(($object+\".childPtr\"))) ) \n"+
"\t\t{\n"+
"\t\t\t\tint $cnt = 0;\n"+
"\t\t\t\tstring $connections[];\n"+
"\t\t\t\tstring $parent;\n"+
"\t\t\t\tstring $child = $object;\n"+
"\t\t\t\twhile(`objExists( ($object+\".Parent_\"+$cnt) )` ) \n"+
"\t\t\t\t{ \n"+
"\t\t\t\t\t\t$connections = `listConnections ($object+\".Parent_\"+$cnt)`;\n"+
"\t\t\t\t\t\tif(endsWith($connections[0], \"_DynDriver\")) $parent = substitute(\"_DynDriver\", $connections[0], \"\");\n"+
"\t\t\t\t\t\tif(objExists(($object+\".childPtr\")))\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$connections = `listConnections ($object+\".childPtr\")`;\n"+
"\t\t\t\t\t\t\t$child = $connections[0];\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t\tmenuItem -l (\"Parent to: \"+$parent) -c (\"JTDdynParentSnap(\\\"\"+$child+\"\\\",\"+$cnt+\")\");\n"+
"\t\t\t\t\t\t$cnt++;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tmenuItem -d true;\n"+
"\t\tif( (objExists(($object+\".Follow\"))) || (objExists(($object+\".childPtr\"))) ) \n"+
"\t\t{\n"+
"\t\t\t\tint $cnt = 0;\n"+
"\t\t\t\tstring $connections[];\n"+
"\t\t\t\tstring $parent;\n"+
"\t\t\t\tstring $child = $object;\n"+
"\t\t\t\twhile(`objExists( ($object+\".Follow_\"+$cnt) )` ) \n"+
"\t\t\t\t{ \n"+
"\t\t\t\t\t\t$connections = `listConnections ($object+\".Follow_\"+$cnt)`;\n"+
"\t\t\t\t\t\tif(endsWith($connections[0], \"_DynDriver\")) $parent = substitute(\"_DynDriver\", $connections[0], \"\");\n"+
"\t\t\t\t\t\tif(objExists(($object+\".childPtr\")))\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$connections = `listConnections ($object+\".childPtr\")`;\n"+
"\t\t\t\t\t\t\t$child = $connections[0];\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t\tmenuItem -l (\"Follow: \"+$parent) -c (\"JTDfollowSnap(\\\"\"+$child+\"\\\",\"+$cnt+\")\");\n"+
"\t\t\t\t\t\t$cnt++;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tif(objExists( ($object+\".IKFK\") ))\n"+
"\t\t{\n"+
"\t\t\t\tstring $JTDupSW[] = `listConnections ($object+\".SWup\")`;\n"+
"\t\t\t\tstring $JTDmidSW[] = `listConnections ($object+\".SWmid\")`;\n"+
"\t\t\t\tstring $JTDupFK[] = `listConnections ($object+\".FKup\")`;\n"+
"\t\t\t\tstring $JTDmidFK[] = `listConnections ($object+\".FKmid\")`;\n"+
"\t\t\t\tstring $JTDlowFK[] = `listConnections ($object+\".FKlow\")`;\n"+
"\t\t\t\tstring $JTDupIK[] = `listConnections ($object+\".IKup\")`;\n"+
"\t\t\t\tstring $JTDmidIK[] = `listConnections ($object+\".IKmid\")`;\n"+
"\t\t\t\tstring $JTDIKpos[] = `listConnections ($object+\".IKpos\")`;\n"+
"\t\t\t\tstring $JTDIKcntrl[] = `listConnections ($object+\".IKcntrl\")`;\n"+
"\t\t\t\tstring $JTDPV[] = `listConnections ($object+\".PV\")`;\n"+
"\t\t\t\tstring $JTDPVpos[] = `listConnections ($object+\".PVsnapPos\")`;\n"+
"\t\t\t\tif( `getAttr($object+\".IKFK\")` == 0 ) menuItem -l \"Snap to IK Mode!\" -c (\"JTDmatchIKFK(\\\"\"+$object+\"\\\",\\\"\"+$JTDIKpos[0]+\"\\\",\\\"\"+$JTDIKcntrl[0]+\"\\\",\\\"\"+$JTDPV[0]+\"\\\",\\\"\"+$JTDPVpos[0]+\"\\\")\");\n"+
"\t\t\t\telse if( `getAttr($object+\".IKFK\")` == 1 ) menuItem -l \"Snap to FK Mode!\" -c (\"JTDmatchFKIK(\\\"\"+$object+\"\\\",\\\"\"+$JTDupSW[0]+\"\\\",\\\"\"+$JTDmidSW[0]+\"\\\",\\\"\"+$object+\"\\\",\\\"\"+$JTDupFK[0]+\"\\\",\\\"\"+$JTDmidFK[0]+\"\\\",\\\"\"+$JTDlowFK[0]+\"\\\",\\\"\"+$JTDupIK[0]+\"\\\",\\\"\"+$JTDmidIK[0]+\"\\\")\");\n"+
"\t\t\t\telse \n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t\tmenuItem -l \"Snap to IK Mode!\" -c (\"JTDmatchIKFK(\\\"\"+$object+\"\\\",\\\"\"+$JTDIKpos[0]+\"\\\",\\\"\"+$JTDIKcntrl[0]+\"\\\",\\\"\"+$JTDPV[0]+\"\\\",\\\"\"+$JTDPVpos[0]+\"\\\")\");\n"+
"\t\t\t\t\t\tmenuItem -l \"Snap to FK Mode!\" -c (\"JTDmatchFKIK(\\\"\"+$object+\"\\\",\\\"\"+$JTDupSW[0]+\"\\\",\\\"\"+$JTDmidSW[0]+\"\\\",\\\"\"+$object+\"\\\",\\\"\"+$JTDupFK[0]+\"\\\",\\\"\"+$JTDmidFK[0]+\"\\\",\\\"\"+$JTDlowFK[0]+\"\\\",\\\"\"+$JTDupIK[0]+\"\\\",\\\"\"+$JTDmidIK[0]+\"\\\")\");\n"+
"\t\t\t\t}\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tif(objExists( ($object+\".js_pivotObj\") ) )\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l \"Select Moveable Pivot\" -c (\"js_pivot_createMov (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Apply & Key Moved Pivot\" -c (\"js_pivot_snap (\\\"\"+$object+\"\\\", 1)\");\n"+
"\t\t\tstring $menu = `menuItem -subMenu true -aob true -l \"Pivot Options\"`;\n"+
"\t\t\tmenuItem -l \"Toggle Moveable Pivot Locator\" -c (\"js_pivot_mov_toggle (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Toggle Actual Pivot Locator\" -c (\"js_pivot_toggle (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Reset Pivot\" -c (\"jd_pivot_reset (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\toptionalDagMenuProc( $parent, $object );\n"+
"\t\tstring $menu = `menuItem -subMenu true -aob true -l \"Inputs\"`;\n"+
"\t\tmenu -e \n"+
"\t\t\t-pmc ( \"createHistoryMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t$menu = `menuItem -subMenu true -aob true -l \"Outputs\"`;\n"+
"\t\tmenu -e -pmc ( \"createFutureMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t \t// Look at the shape child of this object\n"+
"\t \t//\n"+
" \t\tstring $shapes[] = `listRelatives -path -s $object`;\n"+
"\t\t// get current selection of shapes\n"+
"\t\tstring $currentSel[] = `ls -sl -dagObjects -shapes` ;\n"+
"\t\tstring $paintParent = \"\" ;\n"+
"\t\tint $selIndex  ;\n"+
" \t\tint $i;\n"+
" \t\tfor ($i = 0; $i < size($shapes); ++$i) \n"+
"\t\t{\n"+
"\t\t\tstring $nodeType = `nodeType $shapes[$i]` ;\n"+
"\t\t\tif ( ( $nodeType == \"nurbsSurface\") ||\n"+
"\t\t\t\t ( $nodeType == \"mesh\") ||\n"+
"\t\t\t\t ( $nodeType == \"subdiv\")) \n"+
"\t\t\t{\n"+
"\t\t\t\t// save the object name if it is not already selected by the user\n"+
"\t\t\t\t// We use this info to select the object if user chooses a paint option\n"+
"\t\t\t\t//\n"+
"\t\t\t\t// If user has selected multiple objects and is using context menu on one of them\n"+
"\t\t\t\t// we do not change the selection list as user may want to paint some attribute \n"+
"\t\t\t\t// on all of them. (It is the way it has been working all along...we don't want to \n"+
"\t\t\t\t// break it )\n"+
"\t\t\t\t\n"+
"\t\t\t\tint $found = 0 ;\n"+
"\t\t\t\tfor( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\tif( $shapes[$i] == $currentSel[ $selIndex  ] )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\t$found = 1 ;\n"+
"\t\t\t\t\t\tbreak ;\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\t\t\tif( $found )\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t$artSelectObject = \"\" ;\n"+
"\t\t\t\t}\n"+
"\t\t\t\telse\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t// check if the object is in component selection mode\n"+
"\t\t\t\t\t// and if it is, do not do any further selection.\n"+
"\t\t\t\t\t// We are assuming that if the object is in hilite mode\n"+
"\t\t\t\t\t// then the user is in component selection mode.\n"+
"\t\t\t\t\t\n"+
"\t\t\t\t\t$currentSel = `ls -hilite` ;\n"+
"\t\t\t\t\tfor( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\tif( $object == $currentSel[ $selIndex  ] )\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$found = 1 ;\n"+
"\t\t\t\t\t\t\tbreak ;\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tif( !$found ) \n"+
"\t\t\t\t\t\t$artSelectObject = $object ;\n"+
"\t\t\t\t\telse\n"+
"\t\t\t\t\t\t$artSelectObject = \"\" ;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\t\t\t$paintParent = `menuItem -subMenu true -aob true -l \"Paint\"`;\n"+
"\t\t\t\tmenu -e\t-pmc ( \"createArtAttrMenuItems \\\"\"+ $paintParent +\"\\\" \"+$object ) $paintParent ;\n"+
"\t\t\t\tsetParent -m $parent;\n"+
"\t\t\t\tbreak ;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t    $menu = `menuItem -subMenu true -l \"Actions\"`;\n"+
"\t\tmenu -e -pmc ( \"createActionsMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t// If the object can handle uv sets then add the uvset menu\n"+
"\t\t//\n"+
"\t\tstring $shape = objectHandlesUvSets( $object );\n"+
"\t\tif ($shape != \"\")\n"+
"\t\t{\n"+
"\t\t\t$menu = `menuItem -subMenu true -l \"UV Sets\"`;\n"+
"\t\t\tmenu -e \n"+
"\t\t\t\t-pmc ( \"createUVsetMenuItems \\\"\"+$menu+\"\\\" \" +$object + \" \"+\n"+
"\t\t\t\t\t  $shape )\n"+
"\t\t\t\t$menu;\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"\t\tstring $shape = objectHandlesColorSets( $object );\n"+
"\t\tif ($shape != \"\")\n"+
"\t\t{\n"+
"\t\t\t$menu = `menuItem -subMenu true -l \"Color Sets\"`;\n"+
"\t\t\tmenu -e \n"+
"\t\t\t\t-pmc ( \"createColorSetMenuItems \\\"\"+$menu+\"\\\" \" +$object + \" \"+\n"+
"\t\t\t\t\t  $shape )\n"+
"\t\t\t\t$menu;\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"\t\t// Shader menu to be able to quickly assign existing shaders\n"+
"\t\t// to the object under the pointer.\n"+
"\t\t//\n"+
"    \tmenuItem -d true;\n"+
" \t\t$menu = `menuItem -subMenu true -l \"Materials\"`;\n"+
" \t\tmenu -e\n"+
"\t\t\t-pmc ( \"createShaderMenuItems \\\"\"+$menu+\"\\\" \"+$object )\n"+
"\t\t\t$menu;\n"+
" \t\tsetParent -m $parent;\n"+
"\t\tint $mentalIsLoaded = 0;\n"+
"\t\tstring $renderer;\n"+
"\t    for ($renderer in `renderer -query -namesOfAvailableRenderers`) {\n"+
"\t\t\tif( $renderer == \"mentalRay\" ) {\n"+
"\t\t\t\t$mentalIsLoaded = 1;\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tif ($mentalIsLoaded) {\n"+
" \t\t\t$menu = `menuItem -subMenu true -l \"Baking\"`;\n"+
" \t\t\tmenu -e\n"+
"\t\t\t\t-pmc ( \"createBakingMenuItems \\\"\"+$menu+\"\\\" \"+$object )\n"+
"\t\t\t\t$menu;\n"+
" \t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"//\t\t{\n"+
"// \t\t\t$menu = `menuItem -subMenu true -l \"Paint\"`;\n"+
"//\t\t\tmenu -e\n"+
"//\t\t\t\t-pmc ( \"createPaintingMenuItems \\\"\"+$menu+\"\\\" \"+$object )\n"+
"//\t\t\t\t$menu;\n"+
"// \t\t\tsetParent -m $parent;\n"+
"//\t\t}\n"+
"\t\tif ($mode == \"Dynamics\") {\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t\tmenuItem -l \"Connect Field\" -c (\"connectDynamic -f \" + $object);\n"+
"\t\t\tmenuItem -l \"Connect Emitter\" -c (\"connectDynamic -em \" + $object);\n"+
"\t\t\tmenuItem -l \"Connect Collision\" -c (\"connectDynamic -c \" + $object);\n"+
"\t\t}\n"+
"\t\t// is there a reference associated with the object ?\n"+
"\t\t// and if so, is it in a loaded or unloaded state?\n"+
"\t\tstring $refNode = `getRelatedReference $object`;\n"+
"\t\tif( size($refNode) > 0) {\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t\tif( `file -rfn $refNode -q -dr` ) {\n"+
"\t\t\t\tmenuItem -l \"Load Related Reference\" -c (\"loadRelatedReference \" + $object);\n"+
"\t\t\t} else {\n"+
"\t\t\t\tmenuItem -l \"Reload Related Reference\" -c (\"loadRelatedReference \" + $object);\n"+
"\t\t\t\tmenuItem -l \"Unload Related Reference\" -c (\"unloadRelatedReference \" + $object);\n"+
"\t\t\t}\n"+
"\t\t\t// Is this reference a proxy? If so, add proxy switch submenu\n"+
"\t\t\t//\n"+
"\t\t\tstring $proxyNodes[] = `getRelatedProxies $refNode`;\n"+
"\t\t\tif(size($proxyNodes) > 0) {\n"+
"\t\t\t\t$menu = `menuItem -subMenu true -l \"Reload Proxy As\"`;\n"+
"\t\t\t\tmenu -e\n"+
"\t\t\t\t\t-pmc ( \"createSwitchProxyMenuItems \\\"\"+$menu+\"\\\" \"+$object + \" \" + $refNode )\n"+
"\t\t\t\t\t$menu;\n"+
"\t\t\t\tsetParent -m $parent;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tsetParent -m $parent;\n"+
"\t} else {\n"+
"\t\twarning(\"Menu \" + $parent + \" doesn't exist.\");\n"+
"\t}\n"+
"}\n"
);

return $cmd;
}


global proc string JTDgetDagMenuScript8()
{
string $cmd = (

"proc optionalDagMenuProc( string $parent, string $item )\n"+
"{\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tstring $shape = \"\";\n"+
"\tint $gotVisible = 0;\n"+
"\tif( size($object) < 1 ) return;\n"+
"\tfor( $i=0; $i<size($object); $i+=1) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor( $i=0; $i<size($object); $i+=1) {\n"+
"\t\t\tif( 0 == getAttr($object[$i] + \".io\")) {\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( \"\" != $shape ) {\n"+
"\t\tstring $nt = `nodeType $shape`;\n"+
"\t\tswitch( $nt ) {\n"+
"\t\t  case \"subdiv\":\n"+
"\t\t\tsubdOptionalDagMenuProc( $parent, $item );\n"+
"\t\t\tmenuItem -d true; \n"+
"\t\t\tbreak;\n"+
"\t\t  default:\n"+
"\t\t\t// Check to make sure we have a kPlugin prefix\n"+
"\t\t\tstring $apiNt = `nodeType -api $shape`;\n"+
"\t\t\tif ( startsWith( $apiNt, \"kPlugin\" ) ) {\n"+
"\t\t\t\tstring $nodeMenuCommand = $nt + \"DagMenuProc\";\n"+
"\t\t\t\tstring $nodeMenuCommandWithArgs = $nodeMenuCommand + \"(\\\"\" + $parent + \"\\\" , \\\"\" + $item + \"\\\" )\";\n"+
"\t\t\t\tif ( exists( $nodeMenuCommand ) ) {\n"+
"\t\t\t\t   eval( $nodeMenuCommandWithArgs );\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"proc int objectIsTrimmed(string $item)\n"+
"// Return true if this is a trimmed surface\n"+
"{\n"+
"\tstring $command = (\"getAttr -size \" + $item + \".trimFace\");\n"+
"\tint $trimCount = eval($command);\n"+
"\treturn ($trimCount != 0);\n"+
"}\n"+
"proc string getControlledHandle(string $item)\n"+
"{\n"+
"\tstring $handle;\n"+
"\tif (size(`ls ($item+\".ikBlend\")`)) {\n"+
"\t\tstring $connHandles[] =\n"+
"\t\t\t`listConnections -type ikHandle ($item+\".ikBlend\")`;\n"+
"\t\tif (size($connHandles)) {\n"+
"\t\t\t$handle = $connHandles[0];\n"+
"\t\t}\n"+
"\t}\n"+
"\treturn $handle;\n"+
"}\n"+
"proc int isIKcontroller(string $item)\n"+
"{\n"+
"\tstring $handle = getControlledHandle($item);\n"+
"\treturn (size($handle) > 0);\n"+
"}\n"+
"proc\n"+
"createFBIKmenuItems(string $parent,\n"+
"\t\t\t\t\tstring $item,\n"+
"\t\t\t\t\tstring $ikReachModeLocation,\n"+
"\t\t\t\t\tstring $keyBodyPartLocation,\n"+
"\t\t\t\t\tstring $keyAllLocation,\n"+
"\t\t\t\t\tstring $keySelectedLocation)\n"+
"{\n"+
"\tstring $reachKeyingMode = \"Reach Mode:\";\n"+
"\tint $rkm = `optionVar -q setIKKey`;\n"+
"\tswitch ($rkm)\n"+
"\t{\n"+
"\t\tcase 1:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" IK\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase 2:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" FK\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase 3:\n"+
"\t\t\t$reachKeyingMode = $reachKeyingMode + \" Simple\";\n"+
"\t\t\tbreak;\n"+
"\t}\t\n"+
"\tmenuItem -rp $ikReachModeLocation -label $reachKeyingMode\n"+
"\t\t-subMenu true\n"+
"\t\t-annotation (uiRes(\"m_dagMenuProc.kDetermineHowAnnot\")) ;\n"+
"\t\tmenuItem -rp \"S\" -label (uiRes(\"m_dagMenuProc.kIK\")) \n"+
"\t\t\t-command FBIKReachKeyingOptionIK;\n"+
"\t\tmenuItem -rp \"N\" -label (uiRes(\"m_dagMenuProc.kFK\")) \n"+
"\t\t\t-command FBIKReachKeyingOptionFK;\n"+
"\t\tmenuItem -rp \"E\" -label (uiRes(\"m_dagMenuProc.kSimpleNoReach\")) \n"+
"\t\t\t-command FBIKReachKeyingOptionSimple;\n"+
"\tsetParent -m $parent;\n"+
"\t\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kKeyAll\")) \n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"1\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keyAllLocation\n"+
"\t\tkeyAllItem;\n"+
"\t\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kKeyBodyPart\")) \n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"2\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keyBodyPartLocation\n"+
"\t\tkeyBodyPartItem;\n"+
"\t\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kKeySelected\")) \n"+
"\t\t-echoCommand true\n"+
"\t\t-c (\"doSetFullBodyIKKeysArgList 2 {\\\"4\\\", \\\"2\\\", \\\"\"+$item+\"\\\"};\")\n"+
"\t\t-rp $keySelectedLocation\n"+
"\t\tkeySelectedItem;\n"+
"}\n"+
"proc checkForSkinInfluenceItem(string $item, string $quadrant)\n"+
"{\n"+
"\tint $isJoint = (nodeType($item) == \"joint\");\n"+
"\t\n"+
"\t// Check if the current context is the skinPaint context \n"+
"\t// and the the joint is connected to a skinCluster\n"+
"\t//\n"+
"\tstring  $currContext = `currentCtx`;\n"+
"\tstring  $currTool    = \"\";\n"+
"\tif(`contextInfo -ex $currContext`) {\n"+
"\t\t$currTool = `contextInfo -c $currContext`;\n"+
"\t}\n"+
"\tstring $paintWeights = (uiRes(\"m_dagMenuProc.kPaintWeights\"));\n"+
"\tif ( $currTool == \"artAttrSkin\" ) {\n"+
"\t\tstring $whichTool = `artAttrCtx -q -whichTool $currContext`;\n"+
"\t\tif ( $whichTool == \"skinWeights\" )  {\n"+
"\t\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\t\tstring $conn;\n"+
"\t\t\tfor($conn in $connL) {\n"+
"\t\t\t\tif (`nodeType $conn` == \"skinCluster\")\n"+
"\t\t\t\t{\t\n"+
"\t\t\t\t\t// select the surface (not the joint) and set\n"+
"\t\t\t\t\t// the joint as the current influence\n"+
"\t\t\t\t\t//\n"+
"\t\t\t\t\tstring $currSel[] = `ls -sl`;\n"+
"\t\t\t\t\tstring $currSelString;\n"+
"\t\t\t\t\tif (size($currSel) > 0) {\n"+
"\t\t\t\t\t\tstring $currObj;\n"+
"\t\t\t\t\t\t$currSelString = \"select -r \";\n"+
"\t\t\t\t\t\tfor ($currObj in $currSel) {\n"+
"\t\t\t\t\t\t\t$currSelString += ($currObj+\" \");\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tmenuItem -label $paintWeights \n"+
"\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t-c ($currSelString+\"; setSmoothSkinInfluence \" + $item)\n"+
"\t\t\t\t\t\t-rp $quadrant\n"+
"\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\t\t// menu for skinCluster paint\n"+
"\t// Check if the current context is the clusterPaint context \n"+
"\t// and the the joint is connected to a jointCluster\n"+
"\t//\n"+
"\telse if ( $isJoint && ($currTool == \"artAttr\") ) {\n"+
"\t\tstring $whichTool = `artAttrCtx -q -whichTool $currContext`;\n"+
"\t\tif ( $whichTool == \"general\" )  {\n"+
"\t\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\t\tstring $conn;\n"+
"\t\t\tfor($conn in $connL) {\n"+
"\t\t\t\tif (`nodeType $conn` == \"jointCluster\")\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\tstring $artCommand = \"artAttrCtx\" ;\n"+
"\t\t\t\t\tstring $attribute = \"cluster.\" + $conn +  \".weights\" ;\n"+
"\t\t\t\t\tmenuItem -label $paintWeights \n"+
"\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t// the following command doesnot update the UI hence we use the next one\n"+
"\t\t\t\t\t\t//-c (\"artAttrCtx -e -pas \\\"cluster.\" + $conn +  \".weights\\\" `currentCtx`\")\n"+
"\t\t\t\t\t\t-c (\"artSetToolAndSelectAttr( \\\"\" + $artCommand + \"\\\", \\\"\" + $attribute + \"\\\" )\")\n"+
"\t\t\t\t\t\t-rp \"N\"\n"+
"\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// menu for joint-set paint\n"+
"\t// Check if the current context is the setPaint context \n"+
"\t// and the the joint is connected to a objectSet via jointCluster\n"+
"\t//\n"+
"\telse if ( $isJoint && ($currTool == \"artSetPaint\") ) {\n"+
"\t\tstring $connL[] = `listConnections ($item+\".worldMatrix\")`;\n"+
"\t\tstring $conn;\n"+
"\t\tfor($conn in $connL) {\n"+
"\t\t\tif (`nodeType $conn` == \"jointCluster\") {\t\n"+
"\t\t\t\tstring $connS[] = `listConnections ($conn+\".message\")`;\n"+
"\t\t\t\tfor($set in $connS) {\n"+
"\t\t\t\t\tif (`nodeType $set` == \"objectSet\") {\n"+
"\t\t\t\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kPaintSetMembership\")) \n"+
"\t\t\t\t\t\t\t-echoCommand true\n"+
"\t\t\t\t\t\t\t// the following command doesnot update the UI hence we use the next one\n"+
"\t\t\t\t\t\t\t//-c (\"artSetPaintCtx -e -settomodify \" + $set + \" `currentCtx`\")\n"+
"\t\t\t\t\t\t\t-c (\"artSetPaintSelectSet( \\\"\" + $set + \"\\\" )\")\n"+
"\t\t\t\t\t\t\t-rp \"N\"\n"+
"\t\t\t\t\t\t\tpaintWeightItem;\n"+
"\t\t\t\t\t\tbreak;\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t}\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc string[] objectSelectMasks(string $item)\n"+
"// Returns the component selection masks that apply to this object\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tswitch ($nt) {\n"+
"\t\tcase \"lattice\":\n"+
"\t\t\t$maskList[0] = \"latticePoint\";\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"locator\":\n"+
"\t\t\t$maskList[0] = \"locator\";\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"nurbsCurve\":\n"+
"\t\t\t$maskList[0] = \"curveParameterPoint\";\n"+
"\t\t\t$maskList[1] = \"controlVertex\";\n"+
"\t\t\t$maskList[2] = \"editPoint\";\n"+
"\t\t\t$maskList[3] = \"hull\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"nurbsSurface\":\n"+
"\t\t\t$maskList[0] = \"isoparm\";\n"+
"\t\t\t$maskList[1] = \"controlVertex\";\n"+
"\t\t\t$maskList[2] = \"surfaceParameterPoint\";\n"+
"\t\t\t$maskList[3] = \"hull\";\n"+
"\t\t\t$maskList[4] = \"surfaceFace\";\n"+
"\t\t\t$maskList[5] = \"surfaceUV\"; \n"+
"\t\t\tif (objectIsTrimmed($shape)) {\n"+
"\t\t\t\t$maskList[6] = \"surfaceEdge\";\n"+
"\t\t\t}\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"mesh\":\n"+
"\t\t\t$maskList[0] = \"edge\";\n"+
"\t\t\t$maskList[1] = \"vertex\";\n"+
"\t\t\t$maskList[2] = \"facet\";\n"+
"\t\t\t$maskList[3] = \"puv\";\n"+
"\t\t\t$maskList[4] = \"pvf\";\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"joint\":\n"+
"\t\t\t$maskList[0] = \"joint\";\t\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"ikHandle\":\n"+
"\t\t\t$maskList[0] = \"ikHandle\";\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"hikEffector\":\n"+
"\t\t// fall through\n"+
"\t\tcase \"hikFloorContactMarker\":\n"+
"\t\t\t$maskList[0] = \"hikEffector\";\t// special case\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"particle\":\n"+
"\t\t\t$maskList[0] = \"particle\";\t// only one choice\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"spring\":\n"+
"\t\t\t$maskList[0] = \"springComponent\";\t// only one choice\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"subdiv\":\n"+
" \t\t\t$maskList[0] = \"subdivMeshPoint\";\t\n"+
" \t\t\t$maskList[1] = \"subdivMeshEdge\";\t\n"+
" \t\t\t$maskList[2] = \"subdivMeshFace\";\t\n"+
" \t\t\t$maskList[3] = \"subdivMeshUV\";\t\n"+
"\t\t\tbreak;\n"+
"\t}\n"+
"\tif (isIKcontroller($item)) {\n"+
"\t\t$maskList[size($maskList)] = \"ikfkHandle\";\n"+
"\t}\n"+
"\treturn $maskList;\n"+
"}\n"+
"global proc string dagMenuProc_selectionMask_melToUI( string $mel )\n"+
"{\n"+
"\tstring $result = $mel; \n"+
" \n"+
"\tswitch ($mel) \n"+
"\t{\n"+
"\t\tcase \"latticePoint\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kLatticePoint\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"locator\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kLocator\"));\n"+
"\t\t\tbreak;\t\t \n"+
"\t\tcase \"controlVertex\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kControlVertex\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"editPoint\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kEditPoint\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"hull\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kHull\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"isoparm\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kIsoparm\"));\n"+
"\t\t\tbreak;\t \t \n"+
"\t\tcase \"subdivMeshEdge\":\n"+
"\t\t\t// fall through\n"+
"\t\tcase \"edge\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kEdge\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"subdivMeshPoint\":\n"+
"\t\t\t// fall through\n"+
"\t\tcase \"vertex\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kVertex\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"joint\":\t\t\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kJoint\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"ikHandle\":\t\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kIkHandle\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"hikEffector\":\t\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kHikEffector\"));\n"+
"\t\t\tbreak;\t \n"+
"\t\tcase \"ikfkHandle\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kIkfkHandle\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"surfaceUV\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kSurfaceUV\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"surfaceParameterPoint\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kSurfacePoint\"));\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"curveParameterPoint\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kCurvePoint\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"surfaceEdge\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kTrimEdge\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"surfaceFace\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kSurfacePatch\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"subdivMeshUV\":\n"+
"\t\t\t// fall through\n"+
"\t\tcase \"puv\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kUV\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"subdivMeshFace\":\n"+
"\t\t\t// fall through\n"+
"\t\tcase \"facet\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kFace\"));\n"+
"\t\t\tbreak;\t\n"+
"\t\tcase \"pvf\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kVertexFace\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"particle\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kParticle\"));\n"+
"\t\t\tbreak;\n"+
"\t\tcase \"springComponent\":\n"+
"\t\t\t$result = (uiRes(\"m_dagMenuProc.kSpring\"));\n"+
"\t\t\tbreak;\t \t \n"+
"\t\tdefault:\n"+
"\t\t\tuiToMelMsg( \"dagMenuProc_selectionMask_melToUI\", $mel, 1 );\n"+
"\t\t\tbreak;\n"+
"\t}\n"+
"\treturn $result;\t\t \t \n"+
"}\n"+
"global proc createSelectMenuItems(string $parent, string $item)\n"+
"// Create a menu that shows the dag parenting for this object\n"+
"{\n"+
"\tstring $maskList[] = `objectSelectMasks($item)`;\n"+
"\tstring $radialPosition[];\n"+
"\tstring $uiName;\n"+
"\tint $i;\n"+
"\tint $isNurbObject     = false;\n"+
"\tint $isPolyObject     = false;\n"+
"\tint $isLatticeObject  = false;\n"+
"\tint $isJointObject    = false;\n"+
"\tint $isHikEffector\t  = false;\n"+
"\tint $isIkHandleObject = false;\n"+
"\tint $isIkFkHandleObject = false;\t\n"+
"\tint $isParticleObject = false;\n"+
"\tint $isSpringObject   = false;\n"+
"\tint $isSubdivObject   = false;\n"+
"\tint $isLocatorObject  = false;\n"+
"\tint $hasComponents\t  = false;\n"+
"\tif (1 <= size($maskList)) {\n"+
"\t\t$isLatticeObject = ($maskList[0] == \"latticePoint\");\n"+
"\t\t$isJointObject = ($maskList[0] == \"joint\");\n"+
"\t\t$isHikEffector = ($maskList[0] == \"hikEffector\");\n"+
"\t\t$isIkHandleObject = ($maskList[0] == \"ikHandle\");\n"+
"\t\t$isParticleObject = ($maskList[0] == \"particle\");\n"+
"\t\t$isSpringObject = ($maskList[0] == \"springComponent\");\n"+
"\t\t$isSubdivObject = ($maskList[0] == \"subdivMeshPoint\");\n"+
"\t\t$isLocatorObject = ($maskList[0] == \"locator\");\n"+
"\t}\n"+
"\tif (2 <= size($maskList)) {\n"+
"\t\t$isNurbObject = ($maskList[1] == \"controlVertex\");\n"+
"\t\t$isPolyObject = ($maskList[1] == \"vertex\");\n"+
"\t}\n"+
"\t// $maxRadialPos keeps track of how many octants of the\n"+
"\t// RMB marking menu will be populated\n"+
"\t//\n"+
"\tint $maskSize = size($maskList);\n"+
"\tint $maxRadialPos = size($maskList);\n"+
"\tif (($maskSize > 0) && ($maskList[$maskSize-1] == \"ikfkHandle\")) {\n"+
"\t\t$isIkFkHandleObject = true;\n"+
"\t\t$maxRadialPos--; // ikfkHandle does not populate like other masks\n"+
"\t}\n"+
"\t$hasComponents = $isLatticeObject || \n"+
"\t\t\t\t\t $isParticleObject ||\n"+
"\t\t\t\t\t $isSubdivObject ||\n"+
"\t\t\t\t\t $isSpringObject ||\n"+
"\t\t\t\t\t $isNurbObject ||\n"+
"\t\t\t\t\t $isPolyObject;\n"+
"\t// NOTE: \n"+
"\t//\t\t\tIf the object has selectable components, then the\n"+
"\t//\t\tradial position \"NE\" will be used for the menuItem:  \n"+
"\t//\t\t\"Revert back to object mode.\"\n"+
"\t//\n"+
"\tsetParent -menu $parent;\n"+
"\t$radialPosition[0] = \"N\";\n"+
"\t$radialPosition[1] = \"W\";\n"+
"\t$radialPosition[2] = \"S\";\n"+
"\t$radialPosition[3] = \"E\";\n"+
"\t$radialPosition[4] = \"SW\";\n"+
"\t$radialPosition[5] = \"SE\";\n"+
"\t$radialPosition[6] = \"NW\";\n"+
"\t$radialPosition[7] = \"NE\";\n"+
"    \n"+
"    string $disableikHandle = (uiRes(\"m_dagMenuProc.kDisableIkHandle\")); \n"+
"    string $enableIkHandle  = (uiRes(\"m_dagMenuProc.kEnableIkHandle\"));\n"+
"\tstring $setPreferred\t= (uiRes(\"m_dagMenuProc.kSetPreferredAngle\"));\n"+
"\tstring $assumePreferred = (uiRes(\"m_dagMenuProc.kAssumePreferredAngle\")); \n"+
"\t\n"+
"\tif ($isNurbObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\t\t\t  \n"+
"\t\t\t  $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\t\t\t  \n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuNURBComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the nurbs is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"NW\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"NW\");\n"+
"\t} else if ($isPolyObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\t\t\t\t\n"+
"\t\t\t\t$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the poly is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"NW\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"NW\");\n"+
"\t} else if ($isLatticeObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tif ($maskList[$i] != \"ikfkHandle\") {\n"+
"\t\t\t\t$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\n"+
"\t\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t\t-ecr false\n"+
"\t\t\t\t\t-c ( \"doMenuLatticeComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t\t $item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t} else if ($isJointObject) {\n"+
"\t\tstring $setCmd = `performSetPrefAngle 2`;\n"+
"\t\tstring $assumeCmd = `performAssumePrefAngle 2`;\t\t\n"+
"\t\t$setCmd += (\" \"+$item);\n"+
"\t\t$assumeCmd += (\" \"+$item);\n"+
"\t\tstring $jts[] = `ls -sl -type joint`;\n"+
"\t\tfor ($jointItem in $jts) {\n"+
"\t\t\tif ($jointItem != $item) {\n"+
"\t\t\t\t$setCmd += (\" \"+$jointItem);\n"+
"\t\t\t\t$assumeCmd += (\" \"+$jointItem);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tmenuItem -label $setPreferred \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c ($setCmd)\n"+
"\t\t\t-rp \"N\"\n"+
"\t\t\tsetPrefAngleItem;\n"+
"\t\t\n"+
"\t\tmenuItem -label $assumePreferred \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c ($assumeCmd)\n"+
"\t\t\t-rp \"S\"\n"+
"\t\t\tassumePrefAngleItem;\n"+
"\t\tstring $hikHandle[] = `listConnections -type hikHandle $item`;\n"+
"\t\tint $isFBIKjoint = (size($hikHandle) > 0);\n"+
"\t\tif ($isFBIKjoint) {\n"+
"\t\t\tcreateFBIKmenuItems($parent, $item,\"W\",\"NE\",\"E\",\"SE\");\n"+
"\t\t}\n"+
"\t\t\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the joint is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"N\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"N\");\n"+
"\t} else if ($isHikEffector){\n"+
"\t\tif (nodeType($item) == \"hikFloorContactMarker\") {\n"+
"\t\t\tstring $parentItems[] = `listRelatives -pa -p $item`;\n"+
"\t\t\tif (size($parentItems) &&\n"+
"\t\t\t\tnodeType($parentItems[0]) == \"hikEffector\") {\n"+
"\t\t\t\t$item = $parentItems[0];\n"+
"\t\t\t} else {\n"+
"\t\t\t\t$isHikEffector = false;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tif ($isHikEffector) {\n"+
"\t\t    string $pivotOffsetPlug = $item + \".pivotOffset\";\n"+
"\t\t    float $pivotOffset[] = `getAttr $pivotOffsetPlug`;\n"+
"\t\t    int $enablePin = (equivalentTol($pivotOffset[0],0.0,0.001) &&\n"+
"\t\t                      equivalentTol($pivotOffset[1],0.0,0.001) &&\n"+
"\t\t                      equivalentTol($pivotOffset[2],0.0,0.001));\n"+
"\t\t    \n"+
"\t\t\t// set pinning for hikEffectors\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kPinBoth\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"3\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"N\"\n"+
"\t\t\t\tpinAllItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kPinTranslate\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"1\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"NW\"\n"+
"\t\t\t\tpinTransItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kPinRotate\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"2\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-enable $enablePin\n"+
"\t\t\t\t-rp \"SW\"\n"+
"\t\t\t\tpinRotItem;\n"+
"\t\t\t\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kUnpin\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"doPinHikEffectors 1 {\\\"0\\\",\\\"\" + $item + \"\\\"};\")\n"+
"\t\t\t\t-rp \"S\"\n"+
"\t\t\t\tunpinItem;\n"+
"\t\t\t\n"+
"\t\t\tcreateFBIKmenuItems($parent, $item,\"W\",\"NE\",\"E\",\"SE\");\n"+
"\t\t}\n"+
"\t} else if ($isLocatorObject) {\n"+
"\t\t// Check if the current context is the skinPaint context \n"+
"\t\t// and the the joint is connected to a skinCluster. If so, add\n"+
"\t\t// Paint Skin Weights to north (\"N\") quadrant\n"+
"\t\t//\n"+
"\t\tcheckForSkinInfluenceItem($item, \"N\");\n"+
"\t} else if ($isIkHandleObject) {\n"+
"\t\tstring $selectikHandlesJointsAnnot = (uiRes(\"m_dagMenuProc.kSelectikHandlesAnnot\"));\n"+
"\t\tstring $selectikHandlesAnnot = (uiRes(\"m_dagMenuProc.kEnableIKHandlesAnnot\"));\n"+
"\t\tmenuItem -label $setPreferred\n"+
"\t\t\t-annotation $selectikHandlesJointsAnnot \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (`performSetPrefAngle 2` + \" \" + $item)\n"+
"\t\t\t-rp \"W\"\n"+
"\t\t\tsetPrefAngleItem;\n"+
"\t\tmenuItem -label $assumePreferred \n"+
"\t\t\t-annotation $selectikHandlesJointsAnnot \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (`performAssumePrefAngle 2` + \" \" + $item)\n"+
"\t\t\t-rp \"E\"\n"+
"\t\t\tassumePrefAngleItem;\n"+
"\t\tmenuItem -label $enableIkHandle \n"+
"\t\t\t-annotation $selectikHandlesAnnot \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -eh \" + $item)\n"+
"\t\t\t-rp \"N\"\n"+
"\t\t\tenableIKHandlesItem;\n"+
"\t\tmenuItem -label $disableikHandle \n"+
"\t\t\t-annotation $selectikHandlesAnnot \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -dh \" + $item)\n"+
"\t\t\t-rp \"S\"\n"+
"\t\t\tdisableIKHandlesItem;\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kEnableSnap\")) \n"+
"\t\t\t-annotation $selectikHandlesAnnot\n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -see \" + $item + \";\" +\n"+
"\t\t\t\t\"ikHandle -e -shf on \" + $item)\n"+
"\t\t\t-rp \"SE\"\n"+
"\t\t\tenableIKHandlesSnapItem;\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kDisableSnap\")) \n"+
"\t\t\t-annotation $selectikHandlesAnnot \n"+
"\t\t\t-echoCommand true\n"+
"\t\t\t-c (\"ikHandle -e -shf off \" + $item)\n"+
"\t\t\t-rp \"SW\"\n"+
"\t\t\tdisableIKHandlesSnapItem;\n"+
"\t\t$maxRadialPos = 6;\n"+
"\t} else if ($isParticleObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\t\t\t   \n"+
"\t\t\t   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\t\t\t   \t\t\t\n"+
"\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuParticleComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} else if ($isSpringObject) {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\t\t\t   \n"+
"\t\t\t   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\t\t\t\n"+
"\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuSpringComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} else if ($isSubdivObject) {\n"+
"\t\tsubdDagMenuProc( 0, $item, $maskList );\n"+
"\t} else {\n"+
"\t\tfor ($i = 0; $i < size($maskList); $i++) {\n"+
"\t\t\tif ($maskList[$i] == \"ikfkHandle\") {\n"+
"\t\t\t\tcontinue;\n"+
"\t\t\t}\n"+
"\t\t\t\n"+
"\t\t\t$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;\n"+
"\t\t\tmenuItem -label $uiName\n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"doMenuComponentSelection(\\\"\" +\n"+
"\t\t\t\t\t$item + \"\\\", \\\"\" +  $maskList[$i] + \"\\\")\")\n"+
"\t\t\t\t-rp $radialPosition[$i];\n"+
"\t\t}\n"+
"\t} \n"+
"\t// If components are present, provide the ability to \n"+
"\t// get back to object mode...\n"+
"\t//\n"+
"\tif ($hasComponents) {\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kObjectMode\")) \n"+
"\t\t\t\t-ecr false\n"+
"\t\t\t\t-c ( \"hilite -unHilite \" + $item + \"; string $selection[] = `ls -sl`;\"\n"+
"\t\t\t\t\t+ \"changeSelectMode -object; select -r $selection;\" )\n"+
"\t\t\t\t-rp \"NE\";\n"+
"\t}\n"+
"\t// Since any object can be an ikfk handle, we only populate the ikfk items\n"+
"\t// in slots that are not already in use.\n"+
"\t//\n"+
"\tif ($isIkFkHandleObject) {\n"+
"\t\tstring $handle = getControlledHandle($item);\n"+
"\t\tif ($maxRadialPos < 8) {\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kSetIKFKKey\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-annotation (uiRes(\"m_dagMenuProc.kSetKeysAnnot\")) \n"+
"\t\t\t\t-rp $radialPosition[7]\n"+
"\t\t\t\t-command (\"select -r \"+$item+\"; SetIKFKKeyframe\");\n"+
"\t\t}\n"+
"\t\tif ($maxRadialPos < 7) {\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kMoveIKToFK\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-annotation (uiRes(\"m_dagMenuProc.kSelectAnIKHandleOrIKFKAnnot\")) \n"+
"\t\t\t\t-rp $radialPosition[6]\n"+
"\t\t\t\t-command (\"select -r \"+$item+\"; MoveIKtoFK\");\n"+
"\t\t}\n"+
"\t\tif ($maxRadialPos < 5) {\n"+
"\t\t\tmenuItem -label $disableikHandle \n"+
"\t\t\t\t-annotation (uiRes(\"m_dagMenuProc.kDisableIKHandleAnnot\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"ikHandle -e -dh \" + $handle)\n"+
"\t\t\t\t-rp $radialPosition[5];\n"+
"\t\t\tmenuItem -label $enableIkHandle \n"+
"\t\t\t\t-annotation (uiRes(\"m_dagMenuProc.kEnableIKHandleAnnot\")) \n"+
"\t\t\t\t-echoCommand true\n"+
"\t\t\t\t-c (\"ikHandle -e -eh \" + $handle)\n"+
"\t\t\t\t-rp $radialPosition[4];\n"+
"\t\t}\n"+
"\t}\n"+
"\tsetParent -menu $parent;\n"+
"}\n"+
"global proc doMenuNURBComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of NURB components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tstring $warn = (uiRes(\"m_dagMenuProc.kEditUVModeWarn\"));\n"+
"\t\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t//\n"+
"\t\tif( $mask == \"surfaceUV\" )\n"+
"\t\t{\n"+
"\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t{\n"+
"\t\t\t\twarning(`format -s $item $warn`);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t} else {\n"+
"\t\tselectType -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -isoparm 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"surfaceUV\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -uv \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\"; \n"+
"\t\t\t\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t\t\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t\t\t\t//\n"+
"\t\t\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\twarning(`format -s $item $warn`);\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tbreak; \n"+
"\t\t\t\tcase \"editPoint\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"controlVertex\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tcase \"hull\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item + \";\"; \n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -hull \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -controlVertex \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -editPoint \" + $item + \";\";\n"+
"\t\t\t\t\t$selectCmd = $selectCmd +\n"+
"\t\t\t\t\t\t\"toggle -state false -uv \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t\t// Test for implicit UVs - If we are in implicit UV mode\n"+
"\t\t\t// UVs are not selectable. So issue a warning.\n"+
"\t\t\t//\n"+
"\t\t\tint $isExplicit[] = `nurbsUVSet -q -ue $item`;\n"+
"\t\t\tif( !$isExplicit[0] )\n"+
"\t\t\t{\n"+
"\t\t\t    warning(`format -s $item $warn`);\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuLatticeComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Changes the selection/display state on this object to allow\n"+
"// selection of the Lattice control points\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (!`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"toggle -\" + $mask + \";\"; \n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuParticleComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of particle\n"+
"// components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -particle 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"particle\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -particle \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuSpringComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Change the selection/display state to allow selection of spring\n"+
"// components\n"+
"//\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -allComponents 1;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -springComponent 2;\";\n"+
"\t\t\t$selectCmd = $selectCmd +\"selectPriority -\" + $mask + \" 3;\";\n"+
"\t\t\tswitch ($mask) {\n"+
"\t\t\t\tcase \"springComponent\":\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state true -\" + $mask + \" \" + $item +\";\"; \n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t\tdefault:\n"+
"\t\t\t\t\t$selectCmd = $selectCmd + \n"+
"\t\t\t\t\t\t\"toggle -state false -springComponent \" + $item + \";\";\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t} else {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc doMenuComponentSelection(string $item, string $mask)\n"+
"//\n"+
"// Changes the selection/display state on this object to allow\n"+
"// selection of the specified selection mask type.\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\thilite $item;\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" true;\";\n"+
"\t} else {\n"+
"\t\tselectType -ocm -alc false;\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" true;\";\n"+
"\t\tif (!`selectMode -q -preset`) {\n"+
"\t\t\t$selectCmd = $selectCmd + \"hilite \" + $item + \";\";\n"+
"\t\t}\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc undoMenuComponentSelection(string $item, string $mask)\n"+
"{\n"+
"\tstring $selectCmd;\n"+
"\tif (`selectMode -q -object`) {\n"+
"\t\t$selectCmd = \"selectType -ocm -\" + $mask + \" false;\";\n"+
"\t} else {\n"+
"\t\t$selectCmd = \"selectType -\" + $mask + \" false;\";\n"+
"\t}\n"+
"\teval $selectCmd;\n"+
"}\n"+
"global proc toggleBoundingBoxDisplay ( string $parent )\n"+
"//\n"+
"// For each shape under the selected parent object, toggle the\n"+
"// state of bounding box display mode.\n"+
"//\n"+
"{\n"+
"\tstring $shapes[] = `listRelatives -shapes $parent`;\n"+
"\tstring $shape;\n"+
"\tfor ( $shape in $shapes ) {\n"+
"\t\tint $overrideOn = `getAttr ( $shape + \".overrideEnabled\")`;\n"+
"\t\tint $lodMode =    `getAttr ( $shape + \".overrideLevelOfDetail\")`;\n"+
"\t\tint $enabled =     $overrideOn && $lodMode == 1;\n"+
"\t\tif ( $enabled ) {\n"+
"\t\t\t// Don't reset the overrideEnabled attribute. It\n"+
"\t\t\t// is used for more than just bounding box display\n"+
"\t\t\t// and turning if off will mess things up of you\n"+
"\t\t\t// have temporarily enabled bounding box display \n"+
"\t\t\t// of an object in a layer.\n"+
"\t\t\tsetAttr ( $shape + \".overrideLevelOfDetail\" ) 0;\n"+
"\t\t} else {\n"+
"\t\t\tsetAttr ( $shape + \".overrideEnabled\") 1;\n"+
"\t\t\tsetAttr ( $shape + \".overrideLevelOfDetail\") 1;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc createActionsMenuItems(string $parent, string $item)\n"+
"//\n"+
"// Creates a menu with common operations to perform on an object\n"+
"//\n"+
"{\t\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kTemplate\"))  -c (\"toggle -template -state on \" + $item);\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kUntemplate\"))  -c (\"toggle -template -state off \" + $item);\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kUnparent\"))  -c (\"parent -w \" + $item);\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kBoundingBox\"))  -c (\"toggleBoundingBoxDisplay \" + $item);\n"+
"}\n"+
"global proc showSG(string $item)\n"+
"{\n"+
"\t//check selection list for faces (polys, subds, nurbs)\n"+
"\tstring $shader = \"\";\n"+
"\tstring $selection[] = `filterExpand -sm 34 -sm 38 -sm 72`;\n"+
"\t// If there are components selected, try to find a component shader\n"+
"\tif( size( $selection ) > 0)\n"+
"\t{\n"+
"\t\tstring $nameBuffer[];\n"+
"\t\tint $numComps = size( $selection );\n"+
"\t\tint $comp;\n"+
"\t\tfor( $comp = 0; $comp < $numComps; $comp++)\n"+
"\t\t{\n"+
"\t\t\ttokenize $selection[ $comp] \".\" $nameBuffer;\n"+
"\t\t\t//if the selected component is on the object under the pointer\n"+
"\t\t\t//get it's shader\n"+
"\t\t\tif ($nameBuffer[0] == $item) {\n"+
"\t\t\t\t$shader = `getComponentShader $selection[$comp]`;\n"+
"\t\t\t\t//check if the shader is already selected - only toggle\n"+
"\t\t\t\t//selection if it is not selected\n"+
"\t\t\t\tstring $shaderSelected[] = `ls -selection $shader`;\n"+
"\t\t\t\tif ( size( $shaderSelected ) == 0){\n"+
"\t\t\t\t\tselect -tgl $shader;\n"+
"\t\t\t\t\n"+
"\t\t\t\t}\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// If we didn't find a component level shader, try for an object level one\n"+
"\tif( size( $shader ) == 0 ) {\n"+
"\t\tstring $allNodes[] = (`listHistory -f true $item` );\n"+
"\t\tstring $node = \"\";\n"+
"\t\tfor ($node in $allNodes) {\n"+
"\t\t\tif(`nodeType $node` == \"shadingEngine\") {\n"+
"\t\t\t\t$shader = $node;\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\t// If we found a shader, show it\n"+
"\tif( size( $shader ) > 0) \n"+
"\t{\n"+
"\t\tshowEditor $shader;\n"+
"\t}\n"+
"}\n"+
"\t\n"+
"global proc showBakeSets(string $item, string $type)\n"+
"{\n"+
"\tstring $possibleBakeSets[] = (`listHistory -f true $item` );\n"+
"\tstring $node = \"\";\n"+
"    int $bakeSetExists = false;\n"+
"\tfor ($node in $possibleBakeSets) {\n"+
"\t\tif(`nodeType $node` == $type)\n"+
"        {\n"+
"\t\t\tshowEditor $node;\n"+
"            $bakeSetExists = true;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"    // If no bake set exists for the $item, then create the\n"+
"    // initial bake set of that $type and assign it to the $item.\n"+
"    //\n"+
"    if (!$bakeSetExists)\n"+
"    {\n"+
"        string $initialBakeSet = \"\";\n"+
"\t\tif($type == \"vertexBakeSet\") \n"+
"        {\n"+
"            $initialBakeSet = \"initialVertexBakeSet\";\n"+
"        }\n"+
"        else if($type == \"textureBakeSet\") \n"+
"        {\n"+
"            $initialBakeSet = \"initialTextureBakeSet\";\n"+
"\t\t}\n"+
"        else\n"+
"        {\n"+
"            string $errorMsg = (uiRes(\"m_dagMenuProc.kBakeSetError\"));\n"+
"            error   -showLineNumber true\n"+
"                (`format -s $type $errorMsg`);\n"+
"            return;\n"+
"        }\n"+
"        // Create it if it does not exist yet.\n"+
"        //\n"+
"        if  ( size(`ls $initialBakeSet`) < 1)\n"+
"        {\n"+
"            createBakeSet($initialBakeSet, $type);\n"+
"        } \n"+
"    \n"+
"        // Assign the initial bake set to the item.\n"+
"        //\n"+
"        assignBakeSet($initialBakeSet, $item);\n"+
"        // Show the initial bake set.\n"+
"        //\n"+
"        showBakeSetAE($initialBakeSet);\n"+
"    }\n"+
"}\n"+
"// Description:  This procedure is called to refresh the baking \n"+
"//  attribute menu items.\n"+
"//\n"+
"global proc refreshBakingAttributeMenu (string $parent, string $item)\n"+
"{\n"+
"    setParent -menu $parent;\n"+
"    int $suitable = bakeSetTypeSuitableForItem(\"textureBakeSet\", $item);\n"+
"    menuItem -edit -enable $suitable textureBakingAttributeItem;\n"+
"    $suitable = bakeSetTypeSuitableForItem(\"vertexBakeSet\", $item);\n"+
"    menuItem -edit -enable $suitable vertexBakingAttributeItem;\n"+
"}\n"+
"// Description:  This procedure is called to create the \n"+
"//  baking attribute menu.\n"+
"//\n"+
"proc createBakingAttributeMenu(string $parent, string $item)\n"+
"{\n"+
"    setParent -menu $parent;\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kEditAttributes\"))  \n"+
"        -subMenu true\n"+
"        -tearOff true\n"+
"        -postMenuCommand (\"refreshBakingAttributeMenu \\\"\"\n"+
"                            +$parent+\"|editAttributeItem\\\" \\\"\"\n"+
"                            +$item+\"\\\"\")\n"+
"        editAttributeItem; \n"+
"        menuItem -label (uiRes(\"m_dagMenuProc.kTexture\"))  \n"+
"            -c (\"showBakeSets \\\"\"+$item+\"\\\" \\\"textureBakeSet\\\"\") \n"+
"            textureBakingAttributeItem;\n"+
"        menuItem -label (uiRes(\"m_dagMenuProc.kVertexMenuLabel\"))  \n"+
"            -c (\"showBakeSets \\\"\"+$item+\"\\\" \\\"vertexBakeSet\\\"\") \n"+
"            vertexBakingAttributeItem;\n"+
"    setParent -menu ..;\n"+
"}\n"+
"// Description:  This procedure is called to create the baking\n"+
"//  menu items.\n"+
"//\n"+
"global proc createBakingMenuItems(string $parent, string $item)\n"+
"//\n"+
"//\tCreate the Baking menus for the RMB popup menu.\n"+
"//\n"+
"{\n"+
"\tpopupMenu -e -deleteAllItems $parent;\n"+
"\tsetParent -menu $parent;\n"+
"    createBakingAttributeMenu($parent, $item);\n"+
"\tmenuItem -d true;\n"+
"\tif (!`about -evalVersion`) {\n"+
"\t\tbuildBakingMenus($item);\n"+
"\t}\n"+
"}\n"+
"// Description:  This procedure is called to create the switch proxy\n"+
"//  menu items.\n"+
"//\n"+
"global proc createSwitchProxyMenuItems(string $parent, string $item, string $refNode)\n"+
"//\n"+
"//\tCreate the switch proxy submenu for the RMB popup menu.\n"+
"//\n"+
"{\n"+
"\tpopupMenu -e -deleteAllItems $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $proxyNodes[] = `getRelatedProxies $refNode`;\n"+
"\tint $i;\n"+
"\tstring $proxyLabel;\n"+
"\tstring $proxyTag;\n"+
"\tfor( $i=0; $i<size($proxyNodes); $i+=1) {\n"+
"\t\t$proxyTag = `getAttr ($proxyNodes[$i] + \".proxyTag\")`;\n"+
"\t\t\n"+
"\t\tmenuItem -label $proxyTag -c (\"proxySwitch \" + $proxyNodes[$i]);\n"+
"\t}\n"+
"}\n"+
"global proc createHistoryMenuItems(string $parent, string $item)\n"+
"{\n"+
"\t//\n"+
"\t// Delete all menu entries currently in the popup\n"+
"\t//\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\thistoryPopupFill( $item, false, 1 );\n"+
"}\n"+
"global proc createFutureMenuItems(string $parent, string $item)\n"+
"{\n"+
"\t//\n"+
"\t// Delete all menu entries currently in the popup\n"+
"\t//\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\thistoryPopupFill( $item, true, 1 );\n"+
"}\n"+
"global proc string objectHandlesUvSets(string $item)\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tif ($nt == \"mesh\")\t\n"+
"\t\treturn $shape;\n"+
"\treturn \"\";\n"+
"}\n"+
"global proc createUVsetMenuItems(string $parent, string $item,\n"+
"\t\t\t\t\t\t\t\t string $shape)\n"+
"{\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $cmd = \"polyUVSet -currentUVSet -uvSet \";\n"+
"\tstring $curSet[] = `polyUVSet -q -currentUVSet $shape`;\n"+
"\tstring $names[] = `polyUVSet -q -auv $shape`;\n"+
"\tstring $allProjects[] = `polyUVSet -pr -q $shape`;\n"+
"\tstring $setClearCmd = \"\";\n"+
"\tif (size($allProjects))\n"+
"\t{\n"+
"\t\t$setClearCmd = \"select -d \";\t\t\n"+
"\t\tfor ($p=0; $p<size($allProjects); $p++)\n"+
"\t\t\t$setClearCmd += (\" \" + $allProjects[$p]);\n"+
"\t\t$setClearCmd += \";\";\n"+
"\t}\n"+
"\tint $numNames = size($names);\n"+
"\t// Add in a menu to do uv-linking\n"+
"\tif ($numNames > 0)\n"+
"\t{\t\n"+
"\t\tstring $ann = `getRunTimeCommandAnnotation \"UVCentricUVLinkingEditor\"`;\n"+
"\t\tstring $cmd = \"UVCentricUVLinkingEditor; \" + \"select -r \" + $item;\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kUVLinking\")) \n"+
"\t\t\t-c $cmd\n"+
"\t\t\t-annotation $ann;\n"+
"\t\tmenuItem -divider true;\n"+
"\t}\n"+
"\tfor ($i=0; $i<$numNames; $i++)\n"+
"\t{\n"+
"\t\tstring $uvEditname = (\"\\\"\" + $names[$i] + \"\\\"\");\n"+
"\t\tstring $uvname = $names[$i];\n"+
"\t\tstring $setCurCmd = $cmd + $uvEditname + \" \" + $shape + \";\";\n"+
"\t\t// Find any projections associated with the uvset\n"+
"\t\tstring $projs[];\n"+
"\t\t$projs = `polyUVSet -pr -uvs $uvname -q $shape`;\n"+
"\t\tstring $projCmd;\n"+
"\t\t// Add a divider between items\n"+
"\t\tif ($i > 0)\n"+
"\t\t\tmenuItem -divider true;\n"+
"\t\tif ($uvname == $curSet[0])\n"+
"\t\t{\n"+
"\t\t\tmenuItem -label ($uvname) -c $setClearCmd -checkBox true;\n"+
"\t\t\tfor ($j=0; $j<size($projs); $j++)\n"+
"\t\t\t{\n"+
"\t\t\t\t$projCmd = ($setClearCmd + \"select -add \"+ $projs[$j] + \";setToolTo ShowManips;\"); \n"+
"\t\t\t\tmenuItem -label $projs[$j] -c $projCmd;\n"+
"\t\t\t\tif ($j >= 5)\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\telse\n"+
"\t\t{\n"+
"\t\t\tmenuItem -label ($uvname) -c ($setClearCmd + $setCurCmd) -checkBox false;\n"+
"\t\t\tfor ($j=0; $j<size($projs); $j++)\n"+
"\t\t\t{\n"+
"\t\t\t\t$projCmd = ($setCurCmd + $setClearCmd + \"select -add \"+ $projs[$j] + \";setToolTo ShowManips;\"); \n"+
"\t\t\t\tmenuItem -label $projs[$j] -c $projCmd;\n"+
"\t\t\t\tif ($j >= 5)\n"+
"\t\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"//\n"+
"global proc string objectHandlesColorSets(string $item)\n"+
"{\n"+
"\tstring $maskList[];\n"+
"\tstring $shape = $item;\n"+
"\tint $i;\n"+
"\t// Look at the shape child of this object\n"+
"\t//\n"+
"\tstring $object[] = `listRelatives -path -s $item`;\n"+
"\tint $gotVisible = 0;\n"+
"\tfor ($i = 0; $i < size($object); ++$i) {\n"+
"\t\tif( (0 == getAttr($object[$i] + \".io\")) &&\n"+
"\t\t\tgetAttr($object[$i] + \".v\") ) {\n"+
"\t\t\t$shape = $object[$i];\n"+
"\t\t\t$gotVisible = 1;\n"+
"\t\t\tbreak;\n"+
"\t\t}\n"+
"\t}\n"+
"\tif( !$gotVisible ) {\n"+
"\t\tfor ($i = 0; $i < size($object); ++$i)\n"+
"\t\t{\n"+
"\t\t\tif (getAttr($object[$i] + \".io\") == 0)\n"+
"\t\t\t{\n"+
"\t\t\t\t$shape = $object[$i];\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t}\n"+
"\tstring $nt = `nodeType $shape`;\n"+
"\tif ($nt == \"mesh\")\t\n"+
"\t\treturn $shape;\n"+
"\treturn \"\";\n"+
"}\n"+
"global proc createColorSetMenuItems(string $parent, string $item,\n"+
"\t\t\t\t\t\t\t\t string $shape)\n"+
"{\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\tstring $cmd = \"polyColorSet -currentColorSet -colorSet \";\n"+
"\tstring $curSet[] = `polyColorSet -q -currentColorSet $shape`;\n"+
"\tstring $names[] = `polyColorSet -q -acs $shape`;\n"+
"\tint $numNames = size($names);\n"+
"\t// Add in a menu to access color set editor\n"+
"\tmenuItem -label (uiRes(\"m_dagMenuProc.kColorSetEditor\")) \n"+
"\t\t-ann (getRunTimeCommandAnnotation(\"ColorSetEditor\"))\n"+
"\t\t-command \"colorSetEditor\"\n"+
"\t\t;\n"+
"\tif ($numNames > 0)\n"+
"\t{\t\n"+
"\tmenuItem -divider true;\n"+
"\t}\n"+
"\tfor ($i=0; $i < $numNames; $i++)\n"+
"\t{\n"+
"\t\tstring $colorEditname = (\"\\\"\" + $names[$i] + \"\\\"\");\n"+
"\t\tstring $colorname = $names[$i];\n"+
"\t\tstring $setCurCmd = $cmd + $colorEditname + \" \" + $shape + \";\";\n"+
"\t\t// Add a divider between items\n"+
"\t\tif ($i > 0)\n"+
"\t\t\tmenuItem -divider true;\n"+
"\t\tif ($colorname == $curSet[0])\n"+
"\t\t{\n"+
"\t\t\tmenuItem -label ($colorname) -checkBox true;\n"+
"\t\t}\n"+
"\t\telse\n"+
"\t\t{\n"+
"\t\t\tmenuItem -label ($colorname) -c ($setCurCmd) -checkBox false;\n"+
"\t\t}\n"+
"\t}\n"+
"}\n"+
"global proc createArtAttrMenuItems(\n"+
"\tstring \t\t$parent, \n"+
"\tstring \t\t$item\n"+
")\n"+
"{\t\n"+
"\tpopupMenu -e -dai $parent;\n"+
"\tsetParent -menu $parent;\n"+
"\t\n"+
"\t// add default items which are always displayed in the context menu\n"+
"\tmenuItem -p $parent -label (uiRes(\"m_dagMenuProc.kPaintSelect\"))  -command \"ArtPaintSelectToolOptions\" ;\n"+
"\tmenuItem -p $parent -label (uiRes(\"m_dagMenuProc.kThreeDPaint\"))  -command \"Art3dPaintToolOptions\" ;\n"+
"\tmenuItem -p $parent -label (uiRes(\"m_dagMenuProc.kSculpt\"))  -command \"SculptGeometryToolOptions\" ;\n"+
"\t// Get all paintable attributes\n"+
"\tstring $paintAttr = `artBuildPaintMenu $item`;\n"+
"\tstring $paint = (uiRes(\"m_dagMenuProc.kPaint\"));\n"+
"\t\n"+
"\tif ($paintAttr != \"\")\n"+
"\t{\n"+
"\t\t// if the menu item has not been created, create it.\n"+
"\t\tif( $parent == \"\" )\n"+
"\t\t\t$parent = `menuItem -subMenu true -aob true -label $paint `;\n"+
"\t\t\t\n"+
"\t\n"+
"\t\t// create special purpose painting menu items for objects\n"+
"\t\t// such as cloth\n"+
"\t\t//\n"+
"\t\tstring $excludeNodes[] = createPaintingMenuItems( $parent, $item );\n"+
"\t\t// Create the menu.\n"+
"\t\tartAttrCreateMenuItems( $parent, $paintAttr, $excludeNodes );\n"+
"\t\t\n"+
"\t}\n"+
"}\n"+
"// This has been called because a menu press happened on a DAG object\n"+
"// So find the Object submenu and add the DAG specific items to it.\n"+
"//\n"+
"global proc dagMenuProc(string $parent, string $object)\n"+
"{\n"+
"\tglobal string $artSelectObject ;\n"+
"\tstring $mode = \"\";\n"+
"\tif (`optionVar -exists currentMenuBarTab`) {\n"+
"\t\t$mode = `optionVar -q currentMenuBarTab`;\n"+
"\t} else {\n"+
"\t\toptionVar -sv currentMenuBarTab $mode;\n"+
"\t}\n"+
"\tif (`popupMenu -e -exists $parent`) {\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t// label the object\n"+
"\t\tstring $shortName = `substitute \".*|\" $object \"\"`;\n"+
"\t\tmenuItem -label ($shortName + \"...\") -c (\"showEditor \"+$object);\n"+
"\t\tmenuItem -divider true;\n"+
"\t\tmenuItem -divider true;\n"+
"\t\t// Create the list of selection masks\n"+
"\t\tcreateSelectMenuItems($parent, $object);\n"+
"\t\tmenuItem -d true;\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kSelect\"))  -c (\"select -r \" + $object);\n"+
"\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kSelectHierarchy\"))  -c (\"select -hierarchy \" + $object);\n"+
"    \tmenuItem -d true;\n"+
"\tif( (objExists(($object+\".Parent\"))) || (objExists(($object+\".childPtr\"))) ) \n"+
"\t\t{\n"+
"\t\t\t\tint $cnt = 0;\n"+
"\t\t\t\tstring $connections[];\n"+
"\t\t\t\tstring $parent;\n"+
"\t\t\t\tstring $child = $object;\n"+
"\t\t\t\twhile(`objExists( ($object+\".Parent_\"+$cnt) )` ) \n"+
"\t\t\t\t{ \n"+
"\t\t\t\t\t\t$connections = `listConnections ($object+\".Parent_\"+$cnt)`;\n"+
"\t\t\t\t\t\tif(endsWith($connections[0], \"_DynDriver\")) $parent = substitute(\"_DynDriver\", $connections[0], \"\");\n"+
"\t\t\t\t\t\tif(objExists(($object+\".childPtr\")))\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$connections = `listConnections ($object+\".childPtr\")`;\n"+
"\t\t\t\t\t\t\t$child = $connections[0];\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t\tmenuItem -l (\"Parent to: \"+$parent) -c (\"JTDdynParentSnap(\\\"\"+$child+\"\\\",\"+$cnt+\")\");\n"+
"\t\t\t\t\t\t$cnt++;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tmenuItem -d true;\n"+
"\t\tif( (objExists(($object+\".Follow\"))) || (objExists(($object+\".childPtr\"))) ) \n"+
"\t\t{\n"+
"\t\t\t\tint $cnt = 0;\n"+
"\t\t\t\tstring $connections[];\n"+
"\t\t\t\tstring $parent;\n"+
"\t\t\t\tstring $child = $object;\n"+
"\t\t\t\twhile(`objExists( ($object+\".Follow_\"+$cnt) )` ) \n"+
"\t\t\t\t{ \n"+
"\t\t\t\t\t\t$connections = `listConnections ($object+\".Follow_\"+$cnt)`;\n"+
"\t\t\t\t\t\tif(endsWith($connections[0], \"_DynDriver\")) $parent = substitute(\"_DynDriver\", $connections[0], \"\");\n"+
"\t\t\t\t\t\tif(objExists(($object+\".childPtr\")))\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$connections = `listConnections ($object+\".childPtr\")`;\n"+
"\t\t\t\t\t\t\t$child = $connections[0];\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t\tmenuItem -l (\"Follow: \"+$parent) -c (\"JTDfollowSnap(\\\"\"+$child+\"\\\",\"+$cnt+\")\");\n"+
"\t\t\t\t\t\t$cnt++;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tif(objExists( ($object+\".IKFK\") ))\n"+
"\t\t{\n"+
"\t\t\t\tstring $JTDupSW[] = `listConnections ($object+\".SWup\")`;\n"+
"\t\t\t\tstring $JTDmidSW[] = `listConnections ($object+\".SWmid\")`;\n"+
"\t\t\t\tstring $JTDupFK[] = `listConnections ($object+\".FKup\")`;\n"+
"\t\t\t\tstring $JTDmidFK[] = `listConnections ($object+\".FKmid\")`;\n"+
"\t\t\t\tstring $JTDlowFK[] = `listConnections ($object+\".FKlow\")`;\n"+
"\t\t\t\tstring $JTDupIK[] = `listConnections ($object+\".IKup\")`;\n"+
"\t\t\t\tstring $JTDmidIK[] = `listConnections ($object+\".IKmid\")`;\n"+
"\t\t\t\tstring $JTDIKpos[] = `listConnections ($object+\".IKpos\")`;\n"+
"\t\t\t\tstring $JTDIKcntrl[] = `listConnections ($object+\".IKcntrl\")`;\n"+
"\t\t\t\tstring $JTDPV[] = `listConnections ($object+\".PV\")`;\n"+
"\t\t\t\tstring $JTDPVpos[] = `listConnections ($object+\".PVsnapPos\")`;\n"+
"\t\t\t\tif( `getAttr($object+\".IKFK\")` == 0 ) menuItem -l \"Snap to IK Mode!\" -c (\"JTDmatchIKFK(\\\"\"+$object+\"\\\",\\\"\"+$JTDIKpos[0]+\"\\\",\\\"\"+$JTDIKcntrl[0]+\"\\\",\\\"\"+$JTDPV[0]+\"\\\",\\\"\"+$JTDPVpos[0]+\"\\\")\");\n"+
"\t\t\t\telse if( `getAttr($object+\".IKFK\")` == 1 ) menuItem -l \"Snap to FK Mode!\" -c (\"JTDmatchFKIK(\\\"\"+$object+\"\\\",\\\"\"+$JTDupSW[0]+\"\\\",\\\"\"+$JTDmidSW[0]+\"\\\",\\\"\"+$object+\"\\\",\\\"\"+$JTDupFK[0]+\"\\\",\\\"\"+$JTDmidFK[0]+\"\\\",\\\"\"+$JTDlowFK[0]+\"\\\",\\\"\"+$JTDupIK[0]+\"\\\",\\\"\"+$JTDmidIK[0]+\"\\\")\");\n"+
"\t\t\t\telse \n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t\tmenuItem -l \"Snap to IK Mode!\" -c (\"JTDmatchIKFK(\\\"\"+$object+\"\\\",\\\"\"+$JTDIKpos[0]+\"\\\",\\\"\"+$JTDIKcntrl[0]+\"\\\",\\\"\"+$JTDPV[0]+\"\\\",\\\"\"+$JTDPVpos[0]+\"\\\")\");\n"+
"\t\t\t\t\t\tmenuItem -l \"Snap to FK Mode!\" -c (\"JTDmatchFKIK(\\\"\"+$object+\"\\\",\\\"\"+$JTDupSW[0]+\"\\\",\\\"\"+$JTDmidSW[0]+\"\\\",\\\"\"+$object+\"\\\",\\\"\"+$JTDupFK[0]+\"\\\",\\\"\"+$JTDmidFK[0]+\"\\\",\\\"\"+$JTDlowFK[0]+\"\\\",\\\"\"+$JTDupIK[0]+\"\\\",\\\"\"+$JTDmidIK[0]+\"\\\")\");\n"+
"\t\t\t\t}\n"+
"\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\tif(objExists( ($object+\".js_pivotObj\") ) )\n"+
"\t\t{\n"+
"\t\t\tmenuItem -l \"Select Moveable Pivot\" -c (\"js_pivot_createMov (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Apply & Key Moved Pivot\" -c (\"js_pivot_snap (\\\"\"+$object+\"\\\", 1)\");\n"+
"\t\t\tstring $menu = `menuItem -subMenu true -aob true -l \"Pivot Options\"`;\n"+
"\t\t\tmenuItem -l \"Toggle Moveable Pivot Locator\" -c (\"js_pivot_mov_toggle (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Toggle Actual Pivot Locator\" -c (\"js_pivot_toggle (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tmenuItem -l \"Reset Pivot\" -c (\"jd_pivot_reset (\\\"\"+$object+\"\\\")\");\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t}\n"+
"\t\t\n"+
"\t\toptionalDagMenuProc( $parent, $object );\n"+
"\t\tstring $menu = `menuItem -subMenu true -aob true -label (uiRes(\"m_dagMenuProc.kInputs\")) `;\n"+
"\t\tmenu -e \n"+
"\t\t\t-pmc ( \"createHistoryMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t$menu = `menuItem -subMenu true -aob true -label (uiRes(\"m_dagMenuProc.kOutputs\")) `;\n"+
"\t\tmenu -e -pmc ( \"createFutureMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t \t// Look at the shape child of this object\n"+
"\t \t//\n"+
" \t\tstring $shapes[] = `listRelatives -path -s $object`;\n"+
"\t\t// get current selection of shapes\n"+
"\t\tstring $currentSel[] = `ls -sl -dagObjects -shapes` ;\n"+
"\t\tstring $paintParent = \"\" ;\n"+
"\t\tint $selIndex  ;\n"+
" \t\tint $i;\n"+
" \t\tfor ($i = 0; $i < size($shapes); ++$i) \n"+
"\t\t{\n"+
"\t\t\tstring $nodeType = `nodeType $shapes[$i]` ;\n"+
"\t\t\tif ( ( $nodeType == \"nurbsSurface\") ||\n"+
"\t\t\t\t ( $nodeType == \"mesh\") ||\n"+
"\t\t\t\t ( $nodeType == \"subdiv\")) \n"+
"\t\t\t{\n"+
"\t\t\t\t// save the object name if it is not already selected by the user\n"+
"\t\t\t\t// We use this info to select the object if user chooses a paint option\n"+
"\t\t\t\t//\n"+
"\t\t\t\t// If user has selected multiple objects and is using context menu on one of them\n"+
"\t\t\t\t// we do not change the selection list as user may want to paint some attribute \n"+
"\t\t\t\t// on all of them. (It is the way it has been working all along...we don't want to \n"+
"\t\t\t\t// break it )\n"+
"\t\t\t\t\n"+
"\t\t\t\tint $found = 0 ;\n"+
"\t\t\t\tfor( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\tif( $shapes[$i] == $currentSel[ $selIndex  ] )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\t$found = 1 ;\n"+
"\t\t\t\t\t\tbreak ;\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\t\t\tif( $found )\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t$artSelectObject = \"\" ;\n"+
"\t\t\t\t}\n"+
"\t\t\t\telse\n"+
"\t\t\t\t{\n"+
"\t\t\t\t\t// check if the object is in component selection mode\n"+
"\t\t\t\t\t// and if it is, do not do any further selection.\n"+
"\t\t\t\t\t// We are assuming that if the object is in hilite mode\n"+
"\t\t\t\t\t// then the user is in component selection mode.\n"+
"\t\t\t\t\t\n"+
"\t\t\t\t\t$currentSel = `ls -hilite` ;\n"+
"\t\t\t\t\tfor( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )\n"+
"\t\t\t\t\t{\n"+
"\t\t\t\t\t\tif( $object == $currentSel[ $selIndex  ] )\n"+
"\t\t\t\t\t\t{\n"+
"\t\t\t\t\t\t\t$found = 1 ;\n"+
"\t\t\t\t\t\t\tbreak ;\n"+
"\t\t\t\t\t\t}\n"+
"\t\t\t\t\t}\n"+
"\t\t\t\t\tif( !$found ) \n"+
"\t\t\t\t\t\t$artSelectObject = $object ;\n"+
"\t\t\t\t\telse\n"+
"\t\t\t\t\t\t$artSelectObject = \"\" ;\n"+
"\t\t\t\t}\n"+
"\t\t\t\t\n"+
"\t\t\t\t$paintParent = `menuItem -subMenu true -aob true -label (uiRes(\"m_dagMenuProc.kPaintSubmenu\")) `;\n"+
"\t\t\t\tmenu -e\t-pmc ( \"createArtAttrMenuItems \\\"\"+ $paintParent +\"\\\" \"+$object ) $paintParent ;\n"+
"\t\t\t\tsetParent -m $parent;\n"+
"\t\t\t\tbreak ;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t    $menu = `menuItem -subMenu true -label (uiRes(\"m_dagMenuProc.kActions\")) `;\n"+
"\t\tmenu -e -pmc ( \"createActionsMenuItems \\\"\"+$menu+\"\\\" \"+$object ) $menu;\n"+
"\t\tsetParent -m $parent;\n"+
"\t\t// If the object can handle uv sets then add the uvset menu\n"+
"\t\t//\n"+
"\t\tstring $shape = objectHandlesUvSets( $object );\n"+
"\t\tif ($shape != \"\")\n"+
"\t\t{\n"+
"\t\t\t$menu = `menuItem -subMenu true -label (uiRes(\"m_dagMenuProc.kUVSets\")) `;\n"+
"\t\t\tmenu -e \n"+
"\t\t\t\t-pmc ( \"createUVsetMenuItems \\\"\"+$menu+\"\\\" \" +$object + \" \"+ $shape )\n"+
"\t\t\t\t$menu;\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"\t\tstring $shape = objectHandlesColorSets( $object );\n"+
"\t\tif ($shape != \"\")\n"+
"\t\t{\n"+
"\t\t\t$menu = `menuItem -subMenu true -label (uiRes(\"m_dagMenuProc.kColorSets\")) `;\n"+
"\t\t\tmenu -e \n"+
"\t\t\t\t-pmc ( \"createColorSetMenuItems \\\"\"+$menu+\"\\\" \" +$object + \" \"+ $shape )\n"+
"\t\t\t\t$menu;\n"+
"\t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"\t\t// Shader menu to be able to quickly assign existing shaders\n"+
"\t\t// to the object under the pointer.\n"+
"\t\t//\n"+
"    \tmenuItem -d true;\n"+
" \t\tmenuItem -label (uiRes(\"m_dagMenuProc.kMaterialAttributes\")) -c (\"showSG \"+$object);\n"+
"    \t\n"+
"    \tmenuItem -d true;\n"+
"        \n"+
"        buildShaderMenus($object);\n"+
"        \n"+
"        menuItem -d true;\n"+
"        menuItem -divider true;\n"+
"        string $removeOverrideMenuItem = `menuItem \n"+
"\t\t\t-label (uiRes(\"m_dagMenuProc.kRemoveMaterialOverride\"))\n"+
"            -subMenu true`;\n"+
"        menuItem -edit -postMenuCommand\n"+
"            (\"buildMaterialRemoveOverrideMenu -surface \"+$object+\" \"+$removeOverrideMenuItem)\n"+
"            $removeOverrideMenuItem;\n"+
"        setParent -m ..;\n"+
"\t\tint $mentalIsLoaded = 0;\n"+
"\t\tstring $renderer;\n"+
"\t    for ($renderer in `renderer -query -namesOfAvailableRenderers`) {\n"+
"\t\t\tif( $renderer == \"mentalRay\" ) {\n"+
"\t\t\t\t$mentalIsLoaded = 1;\n"+
"\t\t\t\tbreak;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tif ($mentalIsLoaded) {\n"+
" \t\t\t$menu = `menuItem -subMenu true -label (uiRes(\"m_dagMenuProc.kBaking\")) `;\n"+
" \t\t\tmenu -e\n"+
"\t\t\t\t-pmc ( \"createBakingMenuItems \\\"\"+$menu+\"\\\" \"+$object )\n"+
"\t\t\t\t$menu;\n"+
" \t\t\tsetParent -m $parent;\n"+
"\t\t}\n"+
"\t\tif ($mode == \"dynamicsMenuSet\") {\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kConnectField\"))  -c (\"connectDynamic -f \" + $object);\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kConnectEmitter\"))  -c (\"connectDynamic -em \" + $object);\n"+
"\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kConnectCollision\"))  -c (\"connectDynamic -c \" + $object);\n"+
"\t\t}\n"+
"\t\t// is there a reference associated with the object ?\n"+
"\t\t// and if so, is it in a loaded or unloaded state?\n"+
"\t\tstring $refNode = `getRelatedReference $object`;\n"+
"\t\tif( size($refNode) > 0) {\n"+
"\t\t\tmenuItem -d true;\n"+
"\t\t\tif( `file -rfn $refNode -q -dr` ) {\n"+
"\t\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kLoadRelatedReference\"))  -c (\"loadRelatedReference \" + $object);\n"+
"\t\t\t} else {\n"+
"\t\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kReloadRelatedReference\"))  -c (\"loadRelatedReference \" + $object);\n"+
"\t\t\t\tmenuItem -label (uiRes(\"m_dagMenuProc.kUnloadRelatedReference\"))  -c (\"unloadRelatedReference \" + $object);\n"+
"\t\t\t}\n"+
"\t\t\t// Is this reference a proxy? If so, add proxy switch submenu\n"+
"\t\t\t//\n"+
"\t\t\tstring $proxyNodes[] = `getRelatedProxies $refNode`;\n"+
"\t\t\tif(size($proxyNodes) > 0) {\n"+
"\t\t\t\t$menu = `menuItem -subMenu true -label (uiRes(\"m_dagMenuProc.kReloadProxy\")) `;\n"+
"\t\t\t\tmenu -e\n"+
"\t\t\t\t\t-pmc ( \"createSwitchProxyMenuItems \\\"\"+$menu+\"\\\" \"+$object + \" \" + $refNode )\n"+
"\t\t\t\t\t$menu;\n"+
"\t\t\t\tsetParent -m $parent;\n"+
"\t\t\t}\n"+
"\t\t}\n"+
"\t\tsetParent -m $parent;\n"+
"\t} else {\n"+
"\t\tstring $warn = (uiRes(\"m_dagMenuProc.kMenuWarn\"));\n"+
"\t\twarning(`format -s $parent $warn`);\n"+
"\t}\n"+
"}\n"
);

return $cmd;
}

global proc string JTDgetPivotScripts()
{
string $cmd = (

"//These scripts based on Jason Schliefer's jspivot.mel  All props go to him.  Please support him by visiting his website at www.jonhandhisdog.com\n"+
"global proc js_pivot_createMov (string $control)\n"+
"{\n"+
"    // this proc will toggle the visibility of the mov pivot on, and then select it.  That way the animator can grab it and move\n"+
"    // it to the right place.\n"+
"\tfloat $t[];\n"+
"\tstring $truePiv;\n"+
"        $pivot = `js_pivot_get $control \"js_pivotMovObj\"`;\n"+
"        if ($pivot != \"\")\n"+
"        {\n"+
"            showHidden $pivot;\n"+
"            $truePiv = `js_pivot_get $pivot \"js_pivotObj\"`;\n"+
"            $t = `getAttr ($truePiv + \".t\")`;\n"+
"            setAttr ($pivot + \".t\") $t[0] $t[1] $t[2];\n"+
"        }\n"+
"\tselect $pivot;\n"+
"\tsetToolTo moveSuperContext;\n"+
"}\n"+
"global proc js_pivot_snap (string $control, int $keyOption)\n"+
"{\n"+
"    // Based on the selected object, this procedure will snap the object to the position of the new pivot.\n"+
"        string $object;\n"+
"        string $pivot;\n"+
"        string $pivotMov;\n"+
"        $object = `js_pivot_getObj $control`;\n"+
"        $pivot  = `js_pivot_get $control \"js_pivotObj\"`;\n"+
"        $pivotMov  = `js_pivot_get $control \"js_pivotMovObj\"`;\n"+
"        if (($object == \"\") || ($pivot == \"\") || ($pivotMov == \"\"))\n"+
"        {\n"+
"            error ($control + \" was not set up to handle pivot modification.\\n\");\n"+
"        }\n"+
"        // first, save a keyframe at the previous frame for the object, and the pivot\n"+
" \t$frame = `currentTime -q`;\n"+
"\tif($keyOption == 1)\n"+
"\t{ \n"+
"\t        print (\"Saving a key for \" + $object + \" and \" + $pivot + \" at frame \" + ($frame-1) + \"\\n\");\n"+
"       \t setKeyframe -t ($frame-1) -itt \"linear\" -ott \"linear\" $pivot; \n"+
"\t        setKeyframe -t ($frame-1) $object;\n"+
"\t}\n"+
"        // now get the local translation of pivotMov\n"+
"        $trans = `getAttr ($pivotMov + \".t\")`;\n"+
"        // get the world position\n"+
"        $world = `xform -q -ws -rp $pivotMov`;\n"+
"        // set the position of old pivot to be the same as the new pivot\n"+
"        setAttr ($pivot + \".t\") $trans[0] $trans[1] $trans[2];\n"+
"        // now move the object\n"+
"        move -rpr $world[0] $world[1] $world[2] ($object);\n"+
"        // now save a keyframe\n"+
"\tif($keyOption == 1)\n"+
"\t{\n"+
"        \tsetKeyframe -t ($frame) -itt \"linear\" -ott \"linear\" $pivot; \n"+
"\t        setKeyframe -t ($frame) $object;\n"+
"\t}\n"+
"\t setAttr ($pivotMov+\".v\") 0;\n"+
"        select $object;\n"+
"}\n"+
"global proc string js_pivot_get (string $object, string $type)\n"+
"{\n"+
"    string $return;\n"+
"    string $tmp[0];\n"+
"    // we're going to grab the object's pivot, or the pivot move object.  If $type is \"js_pivotObj\", we'll\n"+
"    // grab the pivot.  If it's \"js_pivotMovObj\", we'll return the move pivot.\n"+
"    //\n"+
"   \n"+
"    // get the object\n"+
"    $object = `js_pivot_getObj $object`;\n"+
"    if ($object != \"\")\n"+
"    {\n"+
"        if (`attributeQuery -exists -node $object $type`)\n"+
"        {\n"+
"            // yep, this object has a pivot.  Let's get it\n"+
"            $tmp = `listConnections -type transform ($object + \".\" + $type)`;\n"+
"            $return = $tmp[0];\n"+
"        }\n"+
"    }\n"+
"    return $return;\n"+
"}\n"+
"global proc string js_pivot_getObj (string $sel)\n"+
"{\n"+
"    // based on the selected item, return the object\n"+
"    string $return;\n"+
"    \n"+
"    if (`attributeQuery -exists -node $sel \"js_pivotObj\"`)\n"+
"    {\n"+
"        $return = $sel;\n"+
"    }\n"+
"    else\n"+
"    {\n"+
"        // okay, we probably have one of the pivots selected..\n"+
"        if ((`attributeQuery -exists -node $sel \"js_pivot\"`) || (`attributeQuery -exists -node $sel \"js_pivotMov\"`))\n"+
"        {\n"+
"            $tmp = `listConnections -p true -d true ($sel + \".message\")`;\n"+
"            string $item;\n"+
"            for ($item in $tmp)\n"+
"            {\n"+
"                // check each one and see if what's connected contains \"js_pivotObj\"\n"+
"                if (`gmatch $item \"*js_pivot*\"`)\n"+
"                {\n"+
"                    // okay, we've got a pivot selected, and we know that the item that we've just found will\n"+
"                    // have the connection to the object we want.\n"+
"                    // let's get rid of the attribute\n"+
"                    string $break[0];\n"+
"                    tokenize ($item, \".\", $break);\n"+
"                    $return = $break[0];\n"+
"                }\n"+
"            }\n"+
"            \n"+
"        }\n"+
"    }\n"+
"    return $return;\n"+
"}\n"+
"global proc js_pivot_toggle (string $control)\n"+
"{\n"+
"        $pivot = `js_pivot_get $control \"js_pivotObj\"`; \n"+
"        $onOff = (!`getAttr ($pivot + \".v\")`); \n"+
"\t setAttr ($pivot + \".v\") $onOff;\n"+
"\t if($onOff == 1) select $pivot;\n"+
"\t else select $control;\n"+
"}\n"+
"global proc js_pivot_mov_toggle (string $control)\n"+
"{\n"+
"        $pivot = `js_pivot_get $control \"js_pivotMovObj\"`; \n"+
"        $onOff = (!`getAttr ($pivot + \".v\")`); \n"+
"        setAttr ($pivot + \".v\") $onOff;\n"+
"\t if($onOff == 1) select $pivot;\n"+
"\t else select $control;\n"+
"}\n"+
"global proc jd_pivot_reset (string $control)\n"+
"{\n"+
"       $pivot = `js_pivot_get $control \"js_pivotMovObj\"`; \n"+
"\tif(objExists(($pivot+\".pivotX\")) ) setAttr ($pivot+\".tx\") `getAttr ($pivot+\".pivotX\")`;\n"+
"\tif(objExists(($pivot+\".pivotY\")) ) setAttr ($pivot+\".ty\") `getAttr ($pivot+\".pivotY\")`;\n"+
"\tif(objExists(($pivot+\".pivotZ\")) ) setAttr ($pivot+\".tz\") `getAttr ($pivot+\".pivotZ\")`;\n"+
"\tjs_pivot_snap($control, 0);\n"+
"}\n"+
"global proc string[] js_pivot_create ()\n"+
"{\n"+
"    // This procedure will create a pivot control on the currently selected objects.\n"+
"    // it will actually create 2 pivots.. one which is hooked up to the pivot, and the other\n"+
"    // which can be used to toggle the re-position of the pivot.\n"+
"    //\n"+
"    // get the selected objects that the user has picked in the 3dView\n"+
"    string $objs[0];\n"+
"    string $pivotObjects[0];\n"+
"    int $pivotCount = 0;\n"+
"    $objs = `ls -sl`;\n"+
"    // for each item selected, we will check and see if a pivot is connected.\n"+
"    // if there isn't one, then we'll create one.  If there is, then we will \n"+
"    // go on to the next object\n"+
"    for ($obj in $objs)\n"+
"    {\n"+
"        string $pivotObj;\n"+
"        $pivotObj = `js_pivot_get $obj \"js_pivotObj\"`;\n"+
"        if ($pivotObj == \"\")\n"+
"        {\n"+
"            // time to create a new pivot\n"+
"            // create a locator\n"+
"            string $locator[0];\n"+
"            $locator = `spaceLocator`;\n"+
"            $locator[0] = `rename $locator[0] ($obj + \"_pivot_anim\")`;\n"+
"            // get the position of the object\n"+
"            $pos = `xform -q -ws -rp $obj`;\n"+
"            // set the position of the locator\n"+
"            move -a -ws $pos[0] $pos[1] $pos[2] $locator[0];\n"+
"            // parent the locator under the $object\n"+
"            parent $locator[0] $obj;\n"+
"            // set the locator's rotation to 0\n"+
"            setAttr ($locator[0] + \".r\") 0 0 0;\n"+
"\t\t//makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $locator[0];\n"+
"            // create a new locator which will be used as the second pivot\n"+
"            $dup = `duplicate $locator[0]`;\n"+
"            $dupLoc = `rename $dup[0] ($obj + \"_pivot_mov\")`;\n"+
"            // scale the duplicated locator a bit smaller\n"+
"            scale .8 .8 .8 $dupLoc;\n"+
"            // connect the locator's translation to the objects rotatePivot\n"+
"            connectAttr -f ($locator[0] + \".t\") ($obj + \".rotatePivot\");\n"+
"            // set the locator's scale and rotate attributes locked and unkeyable\n"+
"            $attrs = {\"rx\", \"ry\", \"rz\", \"sx\", \"sy\", \"sz\"};\n"+
"            for ($at in $attrs)\n"+
"            {\n"+
"                setAttr -l 1 -k 0 ($locator[0] + \".\" + $at);\n"+
"                setAttr -l 1 -k 0 ($dupLoc + \".\" + $at);\n"+
"            }\n"+
"            // set the visibility unkeyable, but not locked\n"+
"            setAttr -k 0 ($locator[0] + \".v\");\n"+
"            setAttr -k 0 ($dupLoc + \".v\");\n"+
"        \n"+
"            hide $dupLoc;\n"+
"            // add an attribute called \"js_pivot\";\n"+
"            addAttr -ln \"js_pivot\" -at \"message\" $locator[0];\n"+
"            addAttr -ln \"js_pivotMov\" -at \"message\" $dupLoc;\n"+
"            addAttr -ln \"js_pivotObj\" -at \"message\" $obj;\n"+
"            addAttr -ln \"js_pivotMovObj\" -at \"message\" $obj;\n"+
"\t\n"+
"\taddAttr -ln pivotX -at double $dupLoc;\n"+
"\tsetAttr -l 1 -k 0 ($dupLoc+\".pivotX\") `getAttr ($dupLoc+\".tx\")`;\n"+
"\taddAttr -ln pivotY -at double $dupLoc;\n"+
"\tsetAttr -l 1 -k 0 ($dupLoc+\".pivotY\") `getAttr ($dupLoc+\".ty\")`;\n"+
"\taddAttr -ln pivotZ -at double $dupLoc;\n"+
"\tsetAttr -l 1 -k 0 ($dupLoc+\".pivotZ\") `getAttr ($dupLoc+\".tz\")`;\n"+
"            connectAttr ($locator[0] + \".message\") ($obj + \".js_pivotObj\") ;\n"+
"            connectAttr ($dupLoc + \".message\") ($obj + \".js_pivotMovObj\") ;\n"+
"            $pivotObjects[$pivotCount++] = $locator[0];\n"+
"            $pivotObjects[$pivotCount++] = $dupLoc;\n"+
"        }\n"+
"    }\n"+
"    return $pivotObjects;\n"+
"}\n"
);

return $cmd;
}