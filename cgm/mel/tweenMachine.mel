// --------------------------------------------------------------------------
// tweenMachine.mel - MEL Script
// --------------------------------------------------------------------------
//
// DESCRIPTION:
//	Creates a new key inbetween the previous and next keys, using a
//	slider to adjust the "bias" or weight that each key has over the
//	new key.  Requested/inspired by Doron Meir.  :)
//
// v2.0 - Major upgrade from version 1.  Version 1 history in original script
//
// USAGE:
//	source tweenMachine.mel; tweenMachine;
//
// AUTHOR:
//	Justin Barrett - http://www.justinanimator.com
//
// ADDITIONAL CREDITS:
//	xml_lib.mel: J. Adrian Herbez
//
// COPYRIGHT:
//	Copyright ©2005, 2006 Justin Barrett  - All Rights Reserved
//
// VERSIONS:
//  2.00 - Initial release of upgrade
//  2.01 - fixed issue with "Add Groups" UI display
//       - fixed timeline tick display issue
//       - disabled auto-refresh when opening a scene
//       - added support for character sets
//  2.02 - removed need to source file before running
//       - added support for special tick color (v7 and higher)
//  2.03 - updated tick color support for Maya 200X versions
//  2.04 - bug fix related to character set support
//
//
// ************************************************************************
// ************************************************************************
//                          Startup procedures
// ************************************************************************
// ************************************************************************

global proc tweenMachine() {

	// Global Variables
	global string $tmGroups[], $tmSets[], $tmButtonRGB[], $tmSelConArray;
	global int $tmNumButtons, $tmSliderWidth, $tmShowButtons, $tmShowSliders, $tmButtonRowPad, $mayaVers, $tmSpecTick;
	global float $tmButtonVal[];

	clear $tmGroups;
	clear $tmSets;

	$tmSliderWidth = 200;
	$mayaVers = (int) startString(`about -v`,1);
	$tmSpecTick = 0;
	
	// Source needed libraries
	source xml_lib.mel;

	// OS check -- this will probably go away once the UI is built using forms
	if (`about -mac`) {
		$tmButtonRowPad = 10;
	} else {
		$tmButtonRowPad = 1;
	}

	if (`window -q -ex tweenMachineWin`) deleteUI tweenMachineWin ;

	// Make Window
	window -w 300 -h 5 -mnb 1 -mxb 0 -menuBar 1 -mbv 1 -rtf 1 -s 1 -t "tweenMachine - 2.03" -in "tweenMachine" tweenMachineWin;

	menu -l "File" tmFile;
		menuItem -l "New..." -en 1 -c "tmNew";
		menuItem -d true;
		menuItem -l "Open..." -en 1 -c "tmLoadFromFile";
		menuItem -l "Save..." -en 1 -c "fileBrowser \"tmSaveToFile\" \"Save\" \"\" 1";

	menu -l "Tools" tmTools;
		menuItem -l "Add Set..." -en 0 -c "tmAddSetUI" tmAddSetMI;
		menuItem -l "Add Group..." -c "tmAddGroupUI";
		menuItem -d true;
		menuItem -l "Manage Sets..." -en 1 -c "tmSGMBuildUI(0)";
		menuItem -l "Manage Groups..." -en 1 -c "tmSGMBuildUI(1)";
		//menuItem -d true;
		//menuItem -l "Manage Buttons..." -en 0;
		menuItem -d true;
		menuItem -l "Character Sets..." -sm 1;
			menuItem -l "Add Character Group" -c "tmAddCharacterGroup";
			menuItem -l "Import Character Sets" -c "tmImportCharSets";

	menu -l "Options" -to 1 tmOptions;
		menuItem -l "Sliders" -cb 1 -c "tmShowChange" tmSliderTog;
		menuItem -l "Buttons" -cb 1 -c "tmShowChange" tmButtonTog;
		menuItem -d true;
		menuItem -l "Overshoot" -cb 0 -c "tmToggleOvershoot" tmOvershootTog;
		if ($mayaVers > 6 || $mayaVers == 2) {
			menuItem -d true;
			menuItem -l "Special Tick Color" -cb 0 -c "$tmSpecTick = 1-$tmSpecTick";
		}


	columnLayout -adj 1 -cat "both" 0 tmMainGroupCL;

	tmBuildAllGroups;

	showWindow tweenMachineWin ;

	
	//scriptJob -p tweenMachineWin -e "SceneOpened" "deleteUI tweenMachineWin; tweenMachine;";
	scriptJob -p tweenMachineWin -e "NewSceneOpened" "deleteUI tweenMachineWin;";
	scriptJob -uid tweenMachineWin "tmRestoreTimeControl";
	
}

// --------------------------------------------------------------------------

global proc tmNew () {

	global string $tmGroups[];

	string $c = "Yes";
	if (size($tmGroups) > 0) $c = `confirmDialog -t "Start over?" -m "Erase all tweenMachine data?" -b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;

	if ($c != "No") {
		delete tmXML1;
		tweenMachine;
	}
}

// --------------------------------------------------------------------------

global proc tmBuildAllGroups () {

	// start with the default data
	tmDefaultData;

	// build the "Selected" set no matter what
	tmBuildSet ("Main", "Selected");
	timeControl -e -mlc animationList timeControl1;

	separator -style "none" -h 5;

	// create master selectionConnection object
	if (!`selectionConnection -ex tmMasterSC`) selectionConnection -lst tmMasterSC;
	
	// If data exists in scene, pull the options and interface data from it
	// if not, build XML data using default values

	int $XMLexists = `objExists tmXML1`;
	if ($XMLexists) {
		tmReadXML;
	} else {
		tmDefaultXML;
	}

	setParent tweenMachineWin;
}

// --------------------------------------------------------------------------

global proc tmDefaultData () {

	global int $tmNumButtons, $tmShowButtons, $tmShowSliders;
	global float $tmButtonVal[];
	global string $tmGroups[], $tmSets[], $tmButtonRGB[];

	clear $tmGroups;
	clear $tmSets;

	$tmNumButtons = 7;
	$tmShowButtons = 1;
	$tmShowSliders = 1;

	clear $tmButtonVal;

	$tmButtonVal[0] = -75;
	$tmButtonVal[1] = -60;
	$tmButtonVal[2] = -33;
	$tmButtonVal[3] = 0;
	$tmButtonVal[4] = 33;
	$tmButtonVal[5] = 60;
	$tmButtonVal[6] = 75;

	int $i;
	for ($i=0; $i<$tmNumButtons; $i++) $tmButtonRGB[$i] = "0.6 0.6 0.6";

}

// --------------------------------------------------------------------------

global proc tmDefaultXML () {

	global int $tmNumButtons, $tmShowButtons, $tmShowSliders;
	global float $tmButtonVal[];
	global string $tmGroups[], $tmSets[], $tmButtonRGB[];

	// build XML-based data structure

	makeNode ("tmXML",1);
		makeNode ("tmOptions",0);
			makeNode ("tmSliderVis",0);
				addContent ("1");
			closeTag;
			makeNode ("tmButtonVis",0);
				addContent ("1");
			closeTag;
			makeNode ("tmButtons id=\"7\"",0);
				for ($i=0; $i<$tmNumButtons; $i++) {
					makeNode ("tmButton",0);
						makeNode ("tmButtonRGB",0);
							addContent ($tmButtonRGB[$i]);
						closeTag;
						makeNode ("tmButtonValue",0);
							addContent ($tmButtonVal[$i]);
						closeTag;
					closeTag;
				}
			closeTag;
		closeTag;
		makeNode ("tmGroups",0);
		closeTag;
	closeTag;

	select -cl;
}

// ************************************************************************
// ************************************************************************
//                         Ticks and Toggles
// ************************************************************************
// ************************************************************************

global proc tmShowChange () {

	global string $tmSets[];

	int $sliderState = `menuItem -q -cb tmSliderTog`;
	int $buttonState = `menuItem -q -cb tmButtonTog`;
	int $sliderEnable = `menuItem -q -en tmSliderTog`;
	int $buttonEnable = `menuItem -q -en tmButtonTog`;

	if (!$sliderState && $buttonState) {
		menuItem -e -en 0 tmButtonTog;
		for ($set in $tmSets) {
			string $fullName = $set + "Bias";
			floatSliderGrp -e -m 0 $fullName;
			rowLayout -e -rat 1 "top" 5 -rat 2 "top" 10 ($set + "OuterRow");
		}
	}

	if ($sliderState && !$buttonEnable) {
		menuItem -e -en 1 tmButtonTog;
		for ($set in $tmSets) {
			string $fullName = $set + "Bias";
			floatSliderGrp -e -m 1 $fullName;
			rowLayout -e -rat 1 "bottom" 10 -rat 2 "top" 0 ($set + "OuterRow");
		}
	}

	if ($sliderState && !$buttonState) {
		menuItem -e -en 0 tmSliderTog;
		for ($set in $tmSets) {
			string $fullName = $set + "Buttons";
			rowLayout -e -m 0 $fullName;
			rowLayout -e -rat 1 "top" 3 ($set + "OuterRow");
		}
	}

	if (!$sliderEnable && $buttonState) {
		menuItem -e -en 1 tmSliderTog;
		for ($set in $tmSets) {
			string $fullName = $set + "Buttons";
			rowLayout -e -m 1 $fullName;
			rowLayout -e -rat 1 "bottom" 10 ($set + "OuterRow");
		}
	}

}

// --------------------------------------------------------------------------

global proc tmToggleOvershoot () {

	global string $tmSets[];
	float $oldMin, $newMin, $newMax;

	float $oldMin = `floatSliderGrp -q -min tmMainSelectedSetBias`;

	if ($oldMin == -100) {
		$newMin = -150;
		$newMax = 150;
	} else {
		$newMin = -100;
		$newMax = 100;
	}
		
	for ($set in $tmSets) {
		string $fullName = $set + "Bias";
		float $oldVal = `floatSliderGrp -q -v $fullName`;
		float $newVal = `clamp $newMin $newMax $oldVal`;
		floatSliderGrp -e -min $newMin -max $newMax -v $newVal $fullName;
	}

}

// --------------------------------------------------------------------------

global proc tmTickToggle (string $objName, string $objParent) {

	global string $tmSets[], $tmGroups[];
	
	if ($objName == "tmMainSelectedSet") {

		// swap selectionConnection
		int $selChk = `checkBox -q -v tmMainSelectedSetTicks`;
		if (!$selChk) {
			timeControl -e -mlc tmMasterSC timeControl1;
		} else {
			timeControl -e -mlc animationList timeControl1;
		}

		// toggle "enable" setting for all
		int $en = 1-(`checkBox -q -v tmMainSelectedSetTicks`);

		for ($grp in $tmGroups) {
			string $grpTk = $grp + "Ticks";
			checkBox -e -en $en $grpTk;

			for ($set in tmSetsInGroup($grp,1)) {
				int $v = `checkBox -q -v $grpTk`;
				string $setTk = $set + "Ticks";
				if ($v && $en) checkBox -e -en 1 $setTk;
				if (!$v && $en) checkBox -e -en 0 $setTk;
				if ($v && !$en) checkBox -e -en 0 $setTk;
			}
		}
	} else {
		string $objTk = $objName + "Ticks";
		if (startsWith($objName,"tm")) {
			// object is a set
			string $objSC = $objName + "SC";
			string $parSC = "tm" + $objParent + "GroupSC";

			int $tkStat = `checkBox -q -v $objTk`;
			if ($tkStat) {
				selectionConnection -e -add $objSC $parSC;
			} else {
				selectionConnection -e -rm $objSC $parSC;
			}
		} else {
			// object is a group
			string $objSC = "tm" + $objName + "GroupSC";
			string $parSC = "tmMasterSC";

			int $tkStat = `checkBox -q -v $objTk`;
			if ($tkStat) {
				selectionConnection -e -add $objSC $parSC;
			} else {
				selectionConnection -e -rm $objSC $parSC;
			}

			for ($set in tmSetsInGroup($objName,1)) {
				string $setTk = $set + "Ticks";
				int $s = 1-(`checkBox -q -en $setTk`);
				checkBox -e -en $s $setTk;
			}

		}
	}
}


// ************************************************************************
// ************************************************************************
//                         Manage sets and groups
// ************************************************************************
// ************************************************************************

global proc tmSGMBuildUI (int $mode) {

	// $mode: 0 = manage sets, 1 = manage groups

	global string $sgmArray[], $tmGroups[];
	string $winTitle;

	if (!$mode) $winTitle = "Manage Sets";	else $winTitle = "Manage Groups";

	if (`window -ex tmSGMWin`) deleteUI tmSGMWin;

	window -t $winTitle -w 250 -h 250 -rtf 1 tmSGMWin;

	formLayout -w 250 -nd 100 tmSGMFormLayout;
	
		textScrollList -ams 0 -sc ("tmSGMSelect(" + $mode + ")") -dkc ("tmSGMDelete(" + $mode + ",1)") -da tmSGMList;
		if (!$mode) textScrollList -e -dcc "tmSGMMembers" tmSGMList;
	
		optionMenu -l "Manage:" -cc "tmSGMMode" tmSGMMode;
			menuItem -l "Sets";
			menuItem -l "Groups";
			optionMenu -e -sl ($mode+1) tmSGMMode;
		setParent tmSGMFormLayout;
	
		optionMenu -l "in group: " -cc "tmSGMRebuildList" -m (1-$mode) tmSGMGroups;
			for ($grp in $tmGroups) menuItem -l $grp;
		setParent tmSGMFormLayout;
	
		button -l "Move Up" -al "center" -w 80 -vis 0 -h 1 sgmUp;
		button -l "Move Down" -al "center" -w 80 -vis 0 -h 1 sgmDown;

		//button -l "Move Up" -al "center" -w 80 -en 0 -c ("tmReorderSGMList(-1," + $mode + ")") sgmUp;
		//button -l "Move Down" -al "center" -w 80 -en 0 -c ("tmReorderSGMList(1," + $mode + ")") sgmDown;

		button -l "Rename" -al "center" -w 80 -en 0 -c ("tmSGMRename(" + $mode + ")") sgmRen;
		button -l "Delete" -al "center" -w 80 -en 0 -c ("tmSGMDelete(" + $mode + ",1)") sgmDel;
		button -l "Properties..." -al "center" -w 80 -en 0 -m 0 -c "tmSGMProperties" sgmProp;
		//button -l "Properties..." -al "center" -w 80 -en 0 -m (1-$mode) -c "tmSGMProperties" sgmProp;
	
	formLayout -e

		-af tmSGMMode "top" 5
		-af tmSGMMode "left" 5

		-ac tmSGMGroups "left" 10 tmSGMMode
		-af tmSGMGroups "top" 5
	
		-af sgmUp "right" 5
		-ac sgmUp "top" 5 tmSGMMode
	
		-af sgmDown "right" 5 
		-ac sgmDown "top" 2 sgmUp

		-af sgmRen "right" 5 
		-ac sgmRen "top" 2 sgmDown

		-af sgmDel "right" 5 
		-ac sgmDel "top" 2 sgmRen
	
		-af sgmProp "right" 5 
		-ac sgmProp "top" 2 sgmDel 
	
		-ac tmSGMList "top" 5 tmSGMMode
		-ac tmSGMList "right" 5 sgmUp
		-af tmSGMList "bottom" 5
		-af tmSGMList "left" 5
	
		tmSGMFormLayout;
		
	showWindow tmSGMWin;
	
	tmSGMRebuildList;

}

// ------------------------------------------------------------------------

global proc tmSGMMode () {
	int $i = (`optionMenu -q -sl tmSGMMode`)-1;
	tmSGMBuildUI($i);
}

// ------------------------------------------------------------------------

global proc tmSGMSelect (int $mode) {
	button -e -en 1 sgmRen;
	button -e -en 1 sgmDel;
	//if (!$mode) button -e -en 1 sgmProp;
	int $item[];
	$item = `textScrollList -q -sii tmSGMList`;
	int $numItems = `textScrollList -q -ni tmSGMList`;
	//if ($item[0] > 1) button -e -en 1 sgmUp; else button -e -en 0 sgmUp;
	//if ($item[0] < $numItems) button -e -en 1 sgmDown; else button -e -en 0 sgmDown;
}

// ------------------------------------------------------------------------

global proc tmReorderSGMList (int $dir, int $mode) {
	global string $sgmArray[];

	int $item[], $index;
	$item = `textScrollList -q -sii tmSGMList`;
	$index = $item[0]-1;
	$sgmArray = stringArrayMoveItem($sgmArray,$index,$dir);

	textScrollList -e -ra tmSGMList;

	for ($i in $sgmArray) {
		textScrollList -e -append $i tmSGMList;
	}
	textScrollList -e -sii ($item[0]+$dir) tmSGMList;
	tmSGMSelect($mode);
	button -e -en 1 sgmApp;

}

// ------------------------------------------------------------------------

global proc tmSGMRebuildList() {

	global string $tmGroups[], $sgmArray[];

	int $mode = (`optionMenu -q -sl tmSGMMode`)-1;
	
	clear $sgmArray;
	if (!$mode) {
		string $group = `optionMenu -q -v tmSGMGroups`;
		$sgmArray = tmSetsInGroup($group,0);
	} else {
		$sgmArray = $tmGroups;	
	}

	textScrollList -e -ra tmSGMList;

	for ($item in $sgmArray) textScrollList -e -append $item tmSGMList;

	textScrollList -e -da tmSGMList;
	button -e -en 0 sgmRen;
	button -e -en 0 sgmDel;
	button -e -en 0 sgmDown;
	button -e -en 0 sgmUp;
	
}

// ------------------------------------------------------------------------

global proc tmSGMRename(int $mode) {

	global string $tmGroups[];
	string $modeName[], $item[], $group;
	$modeName[0] = " set";
	$modeName[1] = " group";

	$item = `textScrollList -q -si tmSGMList`;
	string $oldName = $item[0];

	if ($mode == 1 && $oldName == "CharacterSet") {
		confirmDialog -t "Rename not allowed" -m "You are not allowed to rename this item.";
		return;
	}
	
 	string $result = `promptDialog -t ("Rename" + $modeName[$mode]) -message "Enter new name:" -b "OK" -b "Cancel"
 		-defaultButton "OK" -cancelButton "Cancel"
 		-dismissString "Cancel"`;

 	if ($result == "OK") {
		string $newName = `promptDialog -q -text`;
		if (`isValidObjectName($newName)`) {
			if (!$mode) {
				$group = `optionMenu -q -v tmSGMGroups`;
				string $oldNameLong = "tm" + $group + $oldName + "Set";
				string $newNameLong = "tm" + $group + $newName + "Set";

				if (`objExists $newNameLong`) {
					confirmDialog -t "Set exists" -m "A set by that name already exists.  Please choose a new name.";
					return;
				}

				tmSGMRenameSet ($group, $oldNameLong, $newNameLong);

				text -e -l ($newName) ($newNameLong + "Label");

				// change id in XML data node
				string $grpObj = tmFindInXML("tmGroup","tmGroups1",".id",$group);
				string $setObj = tmFindInXML("tmSet",$grpObj,".id",$oldName);
				setAttr -type "string" ($setObj + ".id") $newName;

				tmSGMRebuildList;
			} else {
				for ($grp in $tmGroups) {
					if ($grp == $newName) {
						confirmDialog -t "Group exists" -m "A group by that name already exists.  Please choose a new name.";
						return;
					}
				}
				
				$group = $oldName;
				string $oldPrefix = "tm" + $group;
				string $newPrefix = "tm" + $newName;

				// rename and relabel group frameLayout
				renameUI ($oldPrefix + "Group") ($newPrefix + "Group");
				frameLayout -e -l $newName ($newPrefix + "Group");

				// rename columnLayout
				renameUI ($oldPrefix + "GroupCL") ($newPrefix + "GroupCL");

				// rename tick check box, and change command
				string $checkCommand = "tmTickToggle(\"" + $newName + "\", \"Main\")";
				renameUI ($oldName + "Ticks") ($newName + "Ticks");
				checkBox -e -cc $checkCommand ($newName + "Ticks");

				// rename group SC
				renameUI ($oldPrefix + "GroupSC") ($newPrefix + "GroupSC");
				
				// rename sets in group
				string $set;
				for ($set in tmSetsInGroup($group,0)) {
					string $oldName = $oldPrefix + $set + "Set";
					string $newName = $newPrefix + $set + "Set";
					tmSGMRenameSet ($group, $oldName, $newName);
				}

				// rename item in $tmGroups array
				int $g;
				for ($g=0; $g<=size($tmGroups); $g++) if ($tmGroups[$g] == $group) $tmGroups[$g] = $newName;
				
				// change ID in XML data node
				string $grpObj = tmFindInXML("tmGroup","tmGroups1",".id",$group);
				setAttr -type "string" ($grpObj + ".id") $newName;
				
				tmSGMRebuildList;

			}
	 	} else {
			confirmDialog -t "Invalid name" -m "The name entered is not valid.\nSet and group names must be valid Maya object names.";
		}
	}
}

// ------------------------------------------------------------------------

global proc tmSGMRenameSet(string $group, string $oldName, string $newName) {

	global string $tmSets[];
	global int $tmNumButtons;
	global float $tmButtonVal[];

	rename $oldName $newName;
	renameUI ($oldName + "SC") ($newName + "SC");
	renameUI ($oldName + "Spacer") ($newName + "Spacer");
	renameUI ($oldName + "OuterRow") ($newName + "OuterRow");

	renameUI ($oldName + "Bias") ($newName + "Bias");
	floatSliderGrp -e -cc ("tmSliderStart(\"" + $newName + "\");") ($newName + "Bias");
	
	string $checkCommand = "tmTickToggle(\"" + $newName + "\", \"" + $group + "\")";
	renameUI ($oldName + "Ticks") ($newName + "Ticks");
	checkBox -e -cc $checkCommand ($newName + "Ticks");
	
	renameUI ($oldName + "Buttons") ($newName + "Buttons");
	int $i;
 	for ($i=0; $i<$tmNumButtons; $i++) {
		string $buttonName = $newName + "Button" + $i;
		renameUI ($oldName + "Button" + $i) $buttonName;
		canvas -e -pc ("tmButtonStart(" + $tmButtonVal[$i] + ", \"" + $newName + "\")")  $buttonName ;
	}
		
	renameUI ($oldName + "Label") ($newName + "Label");

	// rename item in $tmSets array
	int $s;
	for ($s=0; $s<=size($tmSets); $s++) if ($tmSets[$s] == $oldName) $tmSets[$s]= $newName;

}

// ------------------------------------------------------------------------

global proc tmSGMDelete(int $mode, int $confirm) {

	global string $tmSets[], $tmGroups[], $sgmArray[];

	string $modeName[];
	$modeName[0] = " set?";
	$modeName[1] = " group?";

	string $i[], $item;
	int $iP[], $itemPos;
	$i = `textScrollList -q -si tmSGMList`;
	$iP = `textScrollList -q -sii tmSGMList`;
	$item = $i[0];
	$itemPos = $iP[0]-1;

	// display confirmation if $confirm is 1
	string $c;
	if ($confirm) {
		string $confirmMsg = "Are you sure you want to delete the \"" + $item + "\"" + $modeName[$mode];
		$c = `confirmDialog -t ("Delete" + $modeName[$mode]) -m $confirmMsg -b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;
	} else $c = "Yes";

	if ($c == "Yes") {
		if (!$mode) {
			// query group from UI
			string $group = `optionMenu -q -v tmSGMGroups`;
			
			// build name of full set
			$setName = "tm" + $group + $item + "Set";

			// remove set from $tmSets array
			$tmSets = stringArrayRemove ({$setName},$tmSets);

			// remove setSC from groupSC, and delete setSC
			string $setSC = $setName + "SC";
			string $grpSC = "tm" + $group + "GroupSC";
			selectionConnection -e -rm $setSC $grpSC;

			// remove set from group in main window
			deleteUI ($setName + "Spacer");
			deleteUI ($setName + "OuterRow");

			// remove set from XML
			for ($set in tmSetsInGroup($group,2)) {
				int $setOrder = `getAttr ($set + ".order")`;
				if ($setOrder == $itemPos) delete $set;
				if ($setOrder > $itemPos) setAttr -type "string" ($set + ".order") ($setOrder -1);
			}

			// remove set
			delete $setName;

			tmSGMRebuildList;

		} else {
			// remove group from $tmGroups array
			$tmGroups = stringArrayRemove ({$item},$tmGroups);

			// remove groupSC from masterSC
			selectionConnection -e -rm ("tm" + $item + "GroupSC") tmMasterSC;

			// remove all sets in group from $tmSets array
			string $set;
			for ($set in tmSetsInGroup($item,1)) {
				$tmSets = stringArrayRemove ({$set},$tmSets);
			}

			if (!size($tmGroups)) menuItem -e -en 0 tmAddSetMI;
			
			// remove group from UI
			deleteUI ("tm" + $item + "Group");

			// remove group from XML
			for ($grp in getByType("tmGroups1","tmGroup")) {
				int $grpOrder = `getAttr ($grp + ".order")`;
				if ($grpOrder == $itemPos) delete $grp;
				if ($grpOrder > $itemPos) setAttr -type "string" ($grp + ".order") ($grpOrder-1);
			}

			tmSGMRebuildList;
		}
		
	}
}

// ************************************************************************
// ************************************************************************
//                         Build sets and groups
// ************************************************************************
// ************************************************************************

global proc tmBuildGroup (string $groupName, int $order) {

	global string $tmGroups[];

	print ("Building group: " + $groupName + "...");

	$tmGroups[$order] = $groupName;
	string $grpPrefix = "tm" + $groupName;
	string $checkCommand = "tmTickToggle(\"" + $groupName + "\", \"Main\")";

	setParent tmMainGroupCL;

	int $s = 1-(`checkBox -q -v tmMainSelectedSetTicks`);
	frameLayout -l $groupName -cl 1 -cll 1 ($grpPrefix + "Group");
		columnLayout ($grpPrefix + "GroupCL");
		checkBox -l "Toggle All" -v 1 -en $s -cc $checkCommand ($groupName + "Ticks");
	
	setParent tweenMachineWin;

	// make selectionConnection for group and add to master
	string $grpSC = $grpPrefix + "GroupSC";
	selectionConnection -p ($grpPrefix + "GroupCL") -lst $grpSC;
	selectionConnection -e -add $grpSC tmMasterSC;

	print ("done.\n");

}

// ------------------------------------------------------------------------

global proc tmBuildSet (string $groupName, string $setName) {

	global string $tmSets[];
	global int $tmSliderWidth, $tmShowSliders;

	$setLabel = $setName;
	
	$setName = "tm" + $groupName + $setName + "Set";
	$tmSets[size($tmSets)] = $setName;

	// if first set (Selected), check and disable
	// if second set or later, check only; enable based on current Selected set check status
	int $tickCheck, $tickEnable;
	if (size($tmSets)==1) {
		$tickCheck = 1;
		$tickEnable = 0;
	} else {
		$tickCheck = 1;
		$tickEnable = 1-(`checkBox -q -v tmMainSelectedSetTicks`);
		checkBox -e -en 1 tmMainSelectedSetTicks;
	}

	string $groupCLName = "tm" + $groupName + "GroupCL"; // this will need to change to the name of the group form
	setParent ($groupCLName);

	separator -style "none" -h 7 ($setName + "Spacer");  // this will go away once the form system is used

	string $checkCommand = "tmTickToggle(\"" + $setName + "\", \"" + $groupName + "\")";
	rowLayout -nc 2 -adj 2 -w 300 -h 30 -rat 1 "bottom" 10 -cat 1 "both" 5 -cal 1 "right" ($setName + "OuterRow");
		columnLayout -adj 1;
			rowLayout -nc 2 -adj 2 -cw2 20 70 -rat 1 "bottom" 5 -rat 2 "bottom" 5;
				checkBox -l "" -v $tickCheck -en $tickEnable -cc $checkCommand -rs 1 ($setName + "Ticks");
				text -l $setLabel -al "right" ($setName + "Label");
			setParent ..;
		setParent ..;
		columnLayout;
			floatSliderGrp -field 1 -min -100.0 -max 100.0 -v 0 -adj 2 -m $tmShowSliders -cw2 40 $tmSliderWidth -cc ("tmSliderStart(\"" + $setName + "\");") ($setName + "Bias");

			tmBuildButtonRow ($setName);

	setParent $groupCLName;

	// make selectionConnection for set and add to parent group's selectionConnection
	if ($setName != "tmMainSelectedSet" && $setName != "tmCharacterSetCurrentSet") {
		string $setSC = $setName + "SC";
		string $grpSC = "tm" + $groupName + "GroupSC";
		selectionConnection -p ($setName + "OuterRow") -obj $setName $setSC;
		selectionConnection -e -add $setSC $grpSC;
	}


}

// ------------------------------------------------------------------------

global proc tmBuildButtonRow (string $setName) {

	global int $tmNumButtons, $tmSliderWidth, $tmShowButtons, $tmButtonRowPad;
	global float $tmButtonVal[];
	global string $tmButtonRGB[];

	int $totalSpace = ($tmNumButtons) * 5;
	int $buttonWidth = floor((($tmSliderWidth)-$totalSpace)/$tmNumButtons);
	int $leftover = ($tmSliderWidth) - ($totalSpace + ($tmNumButtons * $buttonWidth)) + $tmButtonRowPad;
		
	string $rowLayoutName = $setName + "Buttons";
	if (`rowLayout -exists $rowLayoutName`) deleteUI $rowLayoutName;
	
	string $rowBuilder = "rowLayout -nc " + ($tmNumButtons + 1) + " -w 300 -h 15 -m " + $tmShowButtons + " -cw 1 " + ($leftover + 40);
		
	int $i;
	for ($i=1; $i<=$tmNumButtons; $i++)
		$rowBuilder += " -cw " + ($i + 1) + " " + ($buttonWidth + 5);
	$rowBuilder += " " + $rowLayoutName + ";";
		
	eval $rowBuilder;
		
	text -l "" -h 12;

 	for ($i=0; $i<$tmNumButtons; $i++) {

		string $buttonName = $setName + "Button" + $i;
		string $canvasBuilder = "canvas -rgb " + $tmButtonRGB[$i] + " -width " + $buttonWidth;
		$canvasBuilder += " -h 10 -ann " + $tmButtonVal[$i] + " -pc \"tmButtonStart(" + $tmButtonVal[$i] + ",\\\"" + $setName + "\\\")\" " + $buttonName + ";";
		eval $canvasBuilder;
			
	}
}

// ************************************************************************
// ************************************************************************
//                         Add Sets and Groups
// ************************************************************************
// ************************************************************************

global proc tmAddGroupUI () {

	window -t "Add Group" -w 100 -h 5 -rtf 1 -s 0 -mnb 0 -mxb 0 tmGroupUIWin;

	string $command = "tmAddGroup(`textField -q -tx tmGroupUIText`)";
	formLayout -nd 10 tmAddGrpFL;
		text -l "Enter name of new group:" tmAddGrpLabel;
		textField -w 100 -ec $command tmGroupUIText;
		button -l "OK" -al "center" -c $command tmAddGrpOK;

	formLayout -e
		-af tmAddGrpLabel "top" 5
		-af tmAddGrpLabel "left" 5
		-af tmAddGrpLabel "right" 5
		
		-ac tmGroupUIText "top" 5 tmAddGrpLabel
		-af tmGroupUIText "left" 5
		-af tmGroupUIText "right" 5
		
		-ac tmAddGrpOK "top" 5 tmGroupUIText
		-ap tmAddGrpOK "left" 0 2
		-ap tmAddGrpOK "right" 0 8
		
		tmAddGrpFL;
	
	showWindow tmGroupUIWin;

}

// ------------------------------------------------------------------------

global proc tmAddGroup (string $newGroup) {

	global string $tmGroups[], $currParent;

	if (`isValidObjectName($newGroup)`) {
		if (`frameLayout -ex ("tm" + $newGroup + "Group")`) {
			confirmDialog -t "Group exists" -m "A group by that name already exists.  Please choose a new name.";
		} else {
	
			$currParent = "tmGroups1";
			int $order = size($tmGroups);
			string $nodeString = "tmGroup id=\"" + $newGroup + "\" order=\"" + $order + "\"";
			makeNode ($nodeString,0);
	
			select -cl;

			tmBuildGroup ($newGroup, $order);

			if (!`menuItem -q -en tmAddSetMI`) menuItem -e -en 1 tmAddSetMI;
			
			if (`window -ex tmGroupUIWin`) textField -e -tx "" tmGroupUIText;

		}
	} else {
		confirmDialog -t "Invalid name" -m "The name entered is not valid.\nGroup names must be valid Maya object names.";
	}

}

// ------------------------------------------------------------------------

global proc tmAddSetUI () {

	global string $tmGroups[];

	window -t "Add Set" -w 50 -h 10 -rtf 1 -s 0 -mnb 0 -mxb 0 tmSetUIWin;

	string $command = "tmAddSet(`ls -sl`,`textField -q -tx tmSetUIText`,`optionMenu -q -v tmSelectGroup`)";
	formLayout -w 50 -nd 10 tmSetUIFL;

		text -l "Enter name of new set:" tmSetUILabel1;
		textField -ec $command tmSetUIText;

		text -l "Add new set to group:" tmSetUILabel2;
		optionMenu tmSelectGroup;
			for ($grp in $tmGroups) menuItem -l $grp;
		setParent tmSetUIFL;
		button -l "OK" -al "center" -c $command tmSetUIOK;
	
	formLayout -e
	
		-af tmSetUILabel1 "top" 5
		-af tmSetUILabel1 "left" 5
		-af tmSetUILabel1 "right" 5
		
		-ac tmSetUIText "top" 5 tmSetUILabel1
		-af tmSetUIText "left" 5
		-af tmSetUIText "right" 5
		
		-ac tmSetUILabel2 "top" 5 tmSetUIText
		-af tmSetUILabel2 "left" 5 
		-af tmSetUILabel2 "right" 5
		
		-ac tmSelectGroup "top" 5 tmSetUILabel2
		-af tmSelectGroup "left" 5
		-af tmSelectGroup "right" 5
		
		-ac tmSetUIOK "top" 7 tmSelectGroup
		-ap tmSetUIOK "left" 0 2
		-ap tmSetUIOK "right" 0 8
		-af tmSetUIOK "bottom" 5
		
		tmSetUIFL;
	
	showWindow tmSetUIWin;

}

// ------------------------------------------------------------------------

global proc tmAddSet (string $nodes[], string $newSet, string $groupName) {

	global string $tmGroups[], $tmSets[], $currParent;

	if (!size($nodes)) {
		confirmDialog -t "Nothing Selected" -m "You must select one or more objects to make a new set.";
		return;
	}

	if (`isValidObjectName($newSet)`) {

		string $set;
		for ($set in tmSetsInGroup($groupName,0)) {
			if ($newSet == $set) {
				confirmDialog -t "Set exists in selected group" -m "A set by that name already exists in the selected group.\nPlease choose a new set name, or pick a different group.";
				return;
			}
		}

		string $longSetName = "tm" + $groupName + $newSet + "Set";
		
		// create new set
		sets -n $longSetName $nodes;
		select -r $nodes;

		string $groups[];
		$groups = getByType("tmGroups1","tmGroup");

		for ($grp in $groups) {
			if(`getAttr($grp+".id")` == $groupName) {
				$currParent = $grp;
			}
		}

		string $sets[];
		$sets = getByType($currParent,"tmSet");
		int $order = size($sets);

		string $nodeString = "tmSet id=\"" + $newSet + "\" order=\"" + $order + "\"";
		makeNode ($nodeString,0);

		for ($n in $nodes) {
			makeNode ("tmObject",0);
			addContent ($n);
			closeTag;
		}

		select -r $nodes;

		tmBuildSet ($groupName, $newSet);
			
		if (`window -ex tmSetUIWin`) textField -e -tx "" tmSetUIText;
		string $parentLayout = "tm" + $groupName + "Group";
		frameLayout -e -cl 0 $parentLayout;
	} else {
		confirmDialog -t "Invalid name" -m "The name entered is not valid.\nSet names must be valid Maya object names.";
	}

}
// ************************************************************************
// ************************************************************************
//                          Character set utilities
// ************************************************************************
// ************************************************************************

global proc tmAddCharacterGroup () {

	global string $tmGroups[], $currParent;
	
	// check to see if custom set already exists
	if (`frameLayout -ex "tmCharacterSetGroup"`) {
		confirmDialog -t "Group exists" -m "A group and set that control the current character set already exist.";
		return;
	}
	
	// add group
	$currParent = "tmGroups1";
	int $order = size($tmGroups);
	string $nodeString = "tmGroup id=\"CharacterSet\" order=\"" + $order + "\"";
	makeNode ($nodeString,0);
	
	tmBuildGroup ("CharacterSet", $order);

	if (!`menuItem -q -en tmAddSetMI`) menuItem -e -en 1 tmAddSetMI;
	
	// add set named "Current"

	makeNode ("tmSet id=\"Current\" order=\"0\"",0);

	makeNode ("tmObject",0);
	addContent ("tmCustomCharacterSet");
	closeTag;

	tmBuildSet ("CharacterSet", "Current");

}

proc tmGetSubChars (string $curChar, string $group) {
	int $i;
	string $ind, $subChars[], $obj, $charSet;
	
	$charSet = $curChar;
	// if name has namespace, replace colon with underscore
	if (`match ".*:.*" $curChar` != "") $curChar = `substitute ":" $curChar "_"`;

	print ("Adding set for sub-character: " + $charSet + "\n");
	tmAddSet ({$charSet}, $curChar, $group);
	select -cl;
	
	$subChars = `character -q $charSet`;

	for ($obj in $subChars) if (`nodeType $obj` == "character") tmGetSubChars ($obj, $group);
}

global proc tmImportCharSets () {

	string $chars[], $subChars[], $obj, $charSet;
	$chars = `currentCharacters`;

	for ($char in $chars) {
		$charSet = $char;
		// if name has namespace, replace colon with underscore
		if (`match ".*:.*" $char` != "") $char = `substitute ":" $char "_"`;
		
		if (`frameLayout -ex ("tm" + $char + "Group")`) 
			print ("Skipping character: " + $char + " .  Group already exists.\n");
		else {
			print ("Adding group and set for parent character: " + $charSet + "\n");

			tmAddGroup ($char);
			tmAddSet ({$charSet}, $char, $char);
			select -cl;
			
			$subChars = `character -q $charSet`;
	
			for ($obj in $subChars) if (`nodeType $obj` == "character") tmGetSubChars ($obj, $char);

		}
	}
}

// ************************************************************************
// ************************************************************************
//                        Read from XML data in scene
// ************************************************************************
// ************************************************************************

global proc tmReadXML () {

	global string $tmGroups[], $tmSets[], $tmButtonRGB[];
	global int $tmNumButtons, $tmShowButtons, $tmShowSliders;
	global float $tmButtonVal[];

	clear $tmGroups;
	clear $tmSets;
	clear $tmButtonVal;
	clear $tmButtonRGB;

	$tmSets[0] = "tmMainSelectedSet";

	// read button/slider visibility settings
	$tmShowSliders = getData("tmSliderVis1");
	$tmShowButtons = getData("tmButtonVis1");
	menuItem -e -cb $tmShowSliders tmSliderTog;
	menuItem -e -cb $tmShowButtons tmButtonTog;

	// read button values and RGB settings
	$tmNumButtons = (int) `getAttr ("tmButtons1.id")`;
	
	int $i;
	for ($i=0; $i<$tmNumButtons; $i++) {
		string $buttonVal = "tmButtonValue" + ($i+1);
		$tmButtonVal[$i] = `getData ($buttonVal)`;
		string $buttonRGB = "tmButtonRGB" + ($i+1);
		$tmButtonRGB[$i] = `getData ($buttonRGB)`;
	}

	// read groups

	string $groups[];
	$groups = getByType ("tmGroups1","tmGroup");

	for ($grp in $groups) {

		string $grpId = `getAttr ($grp + ".id")`;
		int $grpOrd = `getAttr ($grp + ".order")`;
		$tmGroups[$grpOrd] = $grpId;
		tmBuildGroup ($grpId,$grpOrd);

		// get sets in the group and put them in order

		string $sets[];
		$sets = getByType ($grp, "tmSet");

		string $tmpSet[];
		clear $tmpSet;

		for ($set in $sets) {

			int $setOrd = `getAttr ($set + ".order")`;
			$tmpSet[$setOrd] = $set;

		}
		
		// build sets into groups
		for ($i=0; $i<size($tmpSet); $i++) {
			
			$setName = `getAttr ($tmpSet[$i] + ".id")`;
			string $longSetName = "tm" + $grpId + $setName + "Set";

			// read objects in the set
			string $objects[];
			$objects = getByType ($tmpSet[$i], "tmObject");

			string $obj[];
			clear $obj;
			int $makeSet = 1;
			for ($o in $objects) {
				string $objTmp = `getAttr ($o + ".data")`;
				if (`objExists $objTmp`) 
					$obj[size($obj)] = $objTmp;
				else if ($objTmp == "tmCustomCharacterSet")
					$makeSet = 0;
				else print ("Omitting \"" + $objTmp + "\" from set \"" + $setName + "\". Object does not exist in scene.\n");
				
			}

			// if set does not exist, build it
			
			if (!`objExists $longSetName` && $makeSet) sets -n $longSetName $obj;

			// add set to group

			tmBuildSet ($grpId, $setName);

		}

	}

	if (size($tmGroups)) menuItem -e -en 1 tmAddSetMI;
}

// ************************************************************************
// ************************************************************************
//                         Save and Load XML Data
// ************************************************************************
// ************************************************************************

global proc int tmSaveToFile (string $file, string $fileType) {

	global int $tmNumButtons, $tmShowButtons, $tmShowSliders;
	global string $tmButtonRGB[];
	global float $tmButtonVal[];

	$fileType = ".xml";

	int $chkAgain = 1;

	if (`filetest -w $file` && endsWith($file,$fileType)) $chkAgain = 0;

	// tack on .XML suffix if not already there
	if (!endsWith($file,$fileType)) $file = $file + $fileType;

	// if current file exists, display overwrite confirmation
	string $c;
	if (`filetest -w $file` && $chkAgain) {
		$c = `confirmDialog -t "Overwrite?" -m "File exists.  Overwrite with current data?" -b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;
	}

	if ($c != "No") {

		$fileId=`fopen $file "w"`;
	
		fprint $fileId "<?xml version=\"1.0\"?>\n";
		fprint $fileId "<tmData>\n";
	
		// export data for options
		fprint $fileId "   <tmOptions>\n";

		// need to add script to export Options data
		fprint $fileId ("      <tmSliderVis>" + $tmShowSliders + "</tmSliderVis>\n");
		fprint $fileId ("      <tmButtonVis>" + $tmShowButtons + "</tmButtonVis>\n");
		fprint $fileId ("      <tmButtons id=\"" + $tmNumButtons + "\">\n");

		int $i = 0;
		for ($i=0; $i<$tmNumButtons; $i++) {
			fprint $fileId "         <tmButton>\n";
			fprint $fileId ("            <tmButtonRGB>" + $tmButtonRGB[$i] + "</tmButtonRGB>\n");
			fprint $fileId ("            <tmButtonValue>" + $tmButtonVal[$i] + "</tmButtonValue>\n");
			fprint $fileId "         </tmButton>\n";
		}

		fprint $fileId ("      </tmButtons>\n");
		fprint $fileId "   </tmOptions>\n";

		// export data for groups and sets
		fprint $fileId "   <tmGroups>\n";

		string $groups[];
		$groups = getByType ("tmGroups1","tmGroup");

		for ($grp in $groups) {
	
			string $grpId = `getAttr ($grp + ".id")`;
			string $grpOrd = `getAttr ($grp + ".order")`;
			fprint $fileId ("      <tmGroup id=\"" + $grpId + "\" order=\"" + $grpOrd + "\">\n");
	
			string $sets[];
			$sets = getByType ($grp,"tmSet");
	
			for ($set in $sets) {
				string $setId = `getAttr ($set + ".id")`;
				string $order = `getAttr ($set + ".order")`;
				fprint $fileId ("         <tmSet id=\"" + $setId + "\"");
				fprint $fileId (" order=\"" + $order + "\"");
				fprint $fileId (">\n");
	
				string $tmObjects[];
				$tmObjects = getByType ($set,"tmObject");
		
				for ($obj in $tmObjects) {
					string $objName = getData($obj);
					fprint $fileId ("            <tmObject>" + $objName + "</tmObject>\n");
				}
				fprint $fileId ("         </tmSet>\n");
			}
			fprint $fileId "      </tmGroup>\n";
		}

		fprint $fileId "   </tmGroups>\n";
		fprint $fileId "</tmData>\n";
		fclose $fileId;

		// return true to close browser dialog
		return 1;

	} else {
		fileBrowser tmSaveToFile "Save" "" 1;
		return 0;
	}

}

// --------------------------------------------------------------------------

global proc tmLoadFromFile () {

	global string $tmSets[];

	string $c;
	// if a set exists, confirm that user wants to load new data
	if (size($tmSets) > 1) $c = `confirmDialog -t "Replace data?" -m "Replace current data with data from file?" -b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;

	if ($c != "No") {

		// show file browser dialog (fileDialog) for user to choose file
		string $file = `fileDialog -dm "*.xml"`;
		if ($file != "") {

			// delete existing XML data
			delete tmXML1;

			// load XML data from file
			loadXML ($file);

			// check that data is valid tweenMachine data
			string $s[] = `ls -sl`;
			string $test[];
			$test = getByType ("XML1","tmOptions");
			if (size($test)==0) {
				confirmDialog -t "Invalid file" -m "Selected file does not contain valid tweenMachine data.";
			} else {
				rename XML1 tmXML1;
				select -cl;
				tweenMachine;
			}
		}
	}

}

// ************************************************************************
// ************************************************************************
//                      Starters and main TM procedure
// ************************************************************************
// ************************************************************************

global proc tmSliderStart (string $name) {

	string $nodes[], $biasCtl;

	$biasCtl = $name + "Bias";
	$poseBias = (`floatSliderGrp -q -v $biasCtl` + 100) / 200;

	if (startsWith($name,"tmCharacterSet")) 
		$nodes = `currentCharacters`;
	else 	if ($biasCtl == "tmMainSelectedSetBias") 
			$nodes = `ls -sl`;
		else
			$nodes = `sets -q $name`;


	tween_Machine ($poseBias,$nodes);

}

// --------------------------------------------------------------------------

global proc tmButtonStart (float $poseBias, string $name) {

	string $nodes[];

	$biasCtl = $name + "Bias";
	floatSliderGrp -e -v $poseBias $biasCtl;
	$poseBias = ($poseBias + 100) / 200;

	if (startsWith ($name, "tmCharacterSet")) 
		$nodes = `currentCharacters`;
	else 	if ($biasCtl == "tmMainSelectedSetBias") 
			$nodes = `ls -sl`;
		else
			$nodes = `sets -q $name`;

	tween_Machine ($poseBias,$nodes);

}

// --------------------------------------------------------------------------

global proc tween_Machine(float $poseBias, string $nodes[]) {
	
	global int $tmSpecTick;
	string $nodes[], $curves[], $newCurves[], $attrs[], $crv, $attr, $biasCtl; 

	clear $curves;
	clear $newCurves;

	string $pf = `getPanel -wf`;

	float $timeRng[] = `timeControl -q -ra timeControl1`;  // get selected range on timeline (as an array)
	int $timeC = $timeRng[0]; // current keyframe, where new key will be added

	$curves = `keyframe -q -name $nodes` ; // get names of all keyframed curves on all selected objects
	$attrs = `channelBox -q -sma "mainChannelBox"`; // get names of selected attributes in channel box

	if (size($attrs) > 0) {
	
	// convert short entries in attribute list to long names
	int $i;
	for ($i=0; $i<size($attrs); $i++) {
		switch ($attrs[$i]) {
			case "tx": $attrs[$i] = "translateX"; break;
			case "ty": $attrs[$i] = "translateY"; break;
			case "tz": $attrs[$i] = "translateZ"; break;
			case "rx": $attrs[$i] = "rotateX"; break;
			case "ry": $attrs[$i] = "rotateY"; break;
			case "rz": $attrs[$i] = "rotateZ"; break;
			case "sx": $attrs[$i] = "scaleX"; break;
			case "sy": $attrs[$i] = "scaleY"; break;
			case "sz": $attrs[$i] = "scaleZ"; break;
			case "v": $attrs[$i] = "visibility"; break;
		}
	}

	// compare selected attributes to curves and build new curves array

	for ($crv in $curves) {
		for ($attr in $attrs) {
			if (endsWith($crv, $attr)) $newCurves[size($newCurves)] = $crv;
		}
	}
	clear $curves;
	$curves = $newCurves;
	}

	waitCursor -state on ;
	
		// For each curve...
	for ($crv in $curves)  {

		// Find time for next and previous keys...
		int $timeP = `findKeyframe -which previous $crv`;
		int $timeN = `findKeyframe -which next $crv`;

		// Find previous and next tangent types
		string $tanInPs[] = `keyTangent -time $timeP -q -itt $crv`;
		string $tanOutPs[] = `keyTangent -time $timeP -q -ott $crv`;
		string $tanInNs[] = `keyTangent -time $timeN -q -itt $crv`;
		string $tanOutNs[] = `keyTangent -time $timeN -q -ott $crv`;

		// Set new in and out tangent types based on previous and next tangent types
		string $tanInC = $tanOutPs[0];
		string $tanOutC = $tanInNs[0];

		// However...if any of the types (previous or next) is "fixed", then use the global (default) tangent instead

		if (($tanInPs[0] == "fixed") || ($tanOutPs[0] == "fixed") || ($tanInNs[0] == "fixed") || ($tanOutNs[0] == "fixed"))
		{
		string $tanInGs[] = `keyTangent -q -g -itt`;
		string $tanOutGs[] = `keyTangent -q -g -ott`;
		$tanInC = $tanInGs[0];
		$tanOutC = $tanOutGs[0];
		}
		else
		{		
		if ($tanOutNs[0] == "step")
			$tanOutC = $tanOutNs[0];
		}

		// Find previous and next key values
		float $valPs[] = `keyframe -time $timeP -q -valueChange $crv` ;
		float $valNs[] = `keyframe -time $timeN -q -valueChange $crv` ;

		float $valP = $valPs[0] ;
		float $valN = $valNs[0] ;

		// Find difference in value between previous and next keys

		float $diff = $valN - $valP ;

		// Find percentage of difference to use based on Pose Bias value

		float $diffToUse = $diff * $poseBias;

		// Find current key value by adding amount used to previous key

		float $valC = $valP + $diffToUse;

		// Set new keyframe

		setKeyframe -t $timeC -v $valC -ott $tanOutC $crv;
		if ($tmSpecTick) keyframe -tds on -t $timeC $crv;
		
		if ($tanInC != "step")
		keyTangent -t $timeC -itt $tanInC $crv;

		}
	
	currentTime -e $timeC;

	setFocus $pf;

	waitCursor -state off ;
	
}

// ************************************************************************
// ************************************************************************
//                         Misc. helper procedures
// ************************************************************************
// ************************************************************************

global proc string[] tmSetsInGroup (string $group, int $type) {
	// $size: 0 for short set names, 1 for full set names, 2 for XML object names

	global string $tmSets[];
	string $setsInGroup[];

	if ($type < 2) {
		for ($set in $tmSets) {
			string $setSW = "tm" + $group;
			if (startsWith ($set, $setSW)) {
				if ($type == 0) {
					$set = `substitute $setSW $set ""`;
					$set = `substitute "Set" $set ""`;
				}
				$setsInGroup[size($setsInGroup)] = $set;
			}
		}
	} else {
		for ($grp in getByType("tmGroups1","tmGroup")) {
			if (`getAttr ($grp + ".id")` == $group) $setsInGroup = getByType($grp,"tmSet");
		}
	}

	return $setsInGroup;
}

// --------------------------------------------------------------------------

global proc string tmFindInXML (string $type, string $parent, string $att, string $val) {

	// find set or group in XML data with parent $parent where attribute $att = value $val
	// $type = 0 (set) or 1 (group)

	string $foundObj;

	string $obj;
	for($obj in getByType($parent,$type)) {
		string $v = `getAttr ($obj + $att)`;
		if ($v == $val) $foundObj = $obj;
	}

	return $foundObj;
}

// --------------------------------------------------------------------------

global proc tmRestoreTimeControl () {
	timeControl -e -mlc animationList timeControl1;
}